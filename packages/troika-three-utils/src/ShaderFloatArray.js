import { DataTexture, Vector2 } from 'three'

/**
 * @class ShaderFloatArray
 *
 * When writing a custom WebGL shader, sometimes you need to pass it an array of floating
 * point numbers that it can read from. Unfortunately this is very difficult to do in WebGL,
 * because:
 *
 *   - GLSL "array" uniforms can only be of a constant length.
 *   - Textures can only hold floating point numbers in WebGL1 if the `OES_texture_float`
 *     extension is available.
 *
 * ShaderFloatArray is an array-like abstraction that encodes its floating point data into
 * an RGBA texture's four Uint8 components, and provides the corresponding ThreeJS uniforms
 * and GLSL code for you to put in your custom shader to query the float values by array index.
 * The values are encoded with standard float32 precision according to IEEE 754 specifications.
 *
 * This should generally only be used within a fragment shader, as some environments (e.g. iOS)
 * only allow texture lookups in fragment shaders.
 *
 * TODO:
 *   - Use a float texture if the extension is available so we can skip the encoding process
 */
export class ShaderFloatArray {
  constructor(name) {
    this.name = name

    /**
     * @type {string}
     * The name of the GLSL vec3 uniform that will hold the texture.
     */
    this.textureUniform = `dataTex_${name}`

    /**
     * @type {string}
     * The name of the GLSL vec3 uniform that will hold the width+height of the texture.
     */
    this.textureSizeUniform = `dataTexSize_${name}`

    /**
     * @property readFunction - the name of the GLSL function that should be called to
     * read data out of the array by index.
     * @type {string}
     */
    this.readFunction = `readDataTex_${name}`

    this._raw = []
    this._texture = new DataTexture(new Uint8Array(0), 0, 0)
    this._textureSize = new Vector2()
    this.length = 0
  }

  /**
   * @property {number} length - the current length of the data array
   */
  set length(length) {
    const raw = this._raw
    if (length !== raw.length) {
      // Update raw array
      while (length > raw.length) {
        raw.push(0)
      }
      raw.length = length

      // Find nearest power-of-two texture dimensions that holds the new length, and update the
      // DataTexture if needed
      const texWidth = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(length))))
      const texHeight = length < texWidth * texWidth / 2 ? texWidth / 2 : texWidth
      const texDataSize = texWidth * texHeight * 4
      const img = this._texture.image
      if (texDataSize !== img.data.length) {
        img.width = texWidth
        img.height = texHeight
        this._textureSize.set(texWidth, texHeight)
        if (texDataSize < img.data.length) {
          img.data = img.data.subarray(0, texDataSize)
        } else {
          const newData = new Uint8Array(texDataSize)
          newData.set(img.data)
          img.data = newData
        }
        this._texture.dispose()
      }
    }
  }
  get length() {
    return this._raw.length
  }

  /**
   * Add a value to the end of the data array
   * @param {number} value
   */
  push(value) {
    return this.set(this.length++, value)
  }

  /**
   * Replace the existing data with that from a new array
   * @param {ArrayLike<number>} array
   */
  setArray(array) {
    this.length = array.length
    for (let i = 0; i < array.length; i++) {
      this.set(i, array[i])
    }
  }

  /**
   * Get the current value at index
   * @param {number} index
   * @return {number}
   */
  get(index) {
    return this._raw[index]
  }

  set(index, value) {
    if (index + 1 > this._raw.length) {
      this.length = index + 1
    }
    if (value !== this._raw[index]) {
      this._raw[index] = value
      encodeFloatToFourInts(
        value,
        this._texture.image.data,
        index * 4
      )
      this._texture.needsUpdate = true
    }
  }

  /**
   * Make a copy of this ShaderFloatArray
   * @return {ShaderFloatArray}
   */
  clone() {
    const clone = new ShaderFloatArray(this.name)
    clone.setArray(this._raw)
    return clone
  }

  /**
   * Retrieve the set of Uniforms that must to be added to the target ShaderMaterial or
   * DerivedMaterial, to feed the GLSL code generated by {@link #getShaderHeaderCode}.
   * @return {Object}
   */
  getShaderUniforms() {
    return {
      [this.textureUniform]: {value: this._texture},
      [this.textureSizeUniform]: {value: this._textureSize},
    }
  }

  /**
   * Retrieve the GLSL code that must be injected into the shader's definitions area to
   * enable reading from the data array. This exposes a function with a name matching
   * the {@link #readFunction} property, which other shader code can call to read values
   * from the array by their index.
   * @return {string}
   */
  getShaderHeaderCode() {
    const {textureUniform, textureSizeUniform, readFunction} = this
    return `
uniform sampler2D ${textureUniform};
uniform vec2 ${textureSizeUniform};

float ${readFunction}(float index) {
  vec2 texUV = vec2(
    mod(index, ${textureSizeUniform}.x) + 0.5,
    floor(index / ${textureSizeUniform}.x) + 0.5
  ) / ${textureSizeUniform};
  vec4 bytes = floor(texture2D(${textureUniform}, texUV) * 255.0 + 0.5);
  float exponent = bytes.x - 127.0;
  float sign = bytes.y >= 128.0 ? -1.0 : 1.0;

  if (sign == 1.0 && bytes.x != 0.0) bytes.y += 128.0;
  float fraction = bytes.y * pow(2.0, -7.0) + bytes.z * pow(2.0, -15.0) + bytes.w * pow(2.0, -23.0);  
  return sign * pow(2.0, exponent) * fraction;
}
`
  }
}

const encoder = /*#__PURE__*/new DataView(new ArrayBuffer(4))

/**
 * Encode a floating point number into a set of four 8-bit unsigned integers.
 * Also see the companion decoder function {@link #decodeFloatFromFourInts}.
 *
 * This uses the same encoding scheme as IEEE 754, but changes the order of the components
 * slightly to make it simpler to decode in GLSL.
 *
 * @param {Number} value - the floating point number to encode. Must be in the range [0, 1]
 *        otherwise the results will be incorrect.
 * @param {Array|Uint8Array} array - an array into which the four ints should be written
 * @param {Number} startIndex - index in the output array at which to start writing the ints
 * @return {Array|Uint8Array}
 */
export function encodeFloatToFourInts(value, array, startIndex) {
  encoder.setFloat32(0, value)
  for (let i = 0; i < 4; i++) {
    array[startIndex + i] = encoder.getUint8(i)
  }
  // Move the "sign" bit from the first to the second uint, so the 8 "exponent" bits to fit into
  // a single uint instead of being split, which is simpler to read in GLSL
  const signMask = array[startIndex] & 0b10000000
  array[startIndex] = (array[startIndex] << 1) | (array[startIndex + 1] >> 7)
  array[startIndex + 1] = signMask | (array[startIndex + 1] & 0b01111111)
}

/**
 * Companion to {@link #encodeFloatToFourInts}
 * @param {Array|Uint8Array} array - an array holding the ints to read from
 * @param {Number} startIndex - index in the array at which to start reading
 */
export function decodeFloatFromFourInts(array, startIndex) {
  // Move the "sign" bit back to the first uint
  encoder.setUint8(0, (array[startIndex + 1] & 0b10000000) | (array[startIndex] >> 1))
  encoder.setUint8(1, ((array[startIndex] & 1) << 7) | (array[startIndex + 1] & 0b01111111))
  encoder.setUint8(2, array[startIndex + 2])
  encoder.setUint8(3, array[startIndex + 3])
  return encoder.getFloat32(0)
}

