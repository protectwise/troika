{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Troika is a collection of JavaScript tools for creating interactive graphics in the browser, with a focus on 3D/WebGL, and optimized for data visualization use cases.</p> <p>The provided tools fall into two main categories:</p> <ul> <li>The Troika Framework, a fully featured framework for managing entire scenes with rich interactivity and high performance, and</li> <li>A growing set of other tools for Three.js, that do not depend on that framework.</li> </ul> <p>The Troika project's main goal is to take aspects of developing interactive graphics that you almost always need, but are difficult to manage yourself, and make them as easy as possible.</p> <p> </p>"},{"location":"#troika-framework","title":"Troika Framework","text":"<p>The Troika JavaScript framework is a system for managing complex imperative graphics APIs with a simple declarative model. It provides:</p> <ul> <li>A component architecture that encapsulates complex graphics APIs behind simple facade objects</li> <li>Declarative description of the scene's structure and how it should change over time</li> <li>CSS-like declarative animations and transitions</li> <li>DOM-like interaction event handling</li> <li>Performance optimizations</li> </ul> <p>At its core, the Troika framework manages a simple mapping from a declarative scene descriptor to a tree of special objects called Facades. Each <code>Facade</code> is a component that knows how to synchronize its state, set as flat properties by the scene descriptor, to a more complex underlying API.</p> <p>On top of that, Troika builds in some things like an event subscription model and declarative animations and transitions for facade properties.</p> <p>Learn more about Troika core concepts.</p>"},{"location":"#troika-3d","title":"Troika 3D","text":"<p>Creating interactive 3D scenes with WebGL is Troika's first focus. It uses Three.js for the heavy lifting of managing WebGL state, and for its solid scene graph model, 3D primitives and math utilities, and shader library.</p> <p>Troika manages the Three.js renderer and common things like world matrix calculations and raycasting for pointer events. Otherwise, it has no knowledge of any 3D primitives; it's up to you to set up your Three.js meshes, geometries, materials, etc. and update them in your <code>Object3DFacade</code> implementations. A solid understanding of Three.js's model is therefore still required.</p> <p>As a very rough analogy: if Three.js provides a DOM for WebGL, then you could consider Troika to be like ReactJS for managing that DOM. It simplifies things, but you still need to know the DOM.</p> <p>Troika 3D also provides some more advanced capabilities like: position-synced HTML overlays, an easy-to-use GPU instancing abstraction, a system for creating flexbox user interfaces, and WebXR support.</p> <p>Learn more about Troika 3D.</p>"},{"location":"#troika-2d","title":"Troika 2D","text":"<p>As a separate package, Troika also provides the ability to define graphics using the 2D Canvas API, using the same scene/facade patterns and core conveniences like animations and pointer events.</p> <p>This can be nice on its own when you don't need 3D, but is also useful as a graceful fallback for when WebGL isn't available in the browser.</p> <p>Learn more about Troika 2D.</p>"},{"location":"#troika-threejs-tools","title":"Troika Three.js Tools","text":"<p>Over time, development of the Troika framework has produced certain tools and techniques that are generally useful for Three.js development. It has become our goal to extract as many of these tools as possible from the Troika framework so they can be used in pure Three.js projects or within other frameworks like AFrame or react-three-fiber.</p> <p>Some of these tools include:</p> <ul> <li>troika-three-text: High quality, high performance text rendering for Three.js.</li> <li>createDerivedMaterial: A utility for extending any Three.js material with custom shader code.</li> <li>InstancedUniformsMesh: An extension of Three's <code>InstancedMesh</code> that allows setting any shader uniform per instance.</li> <li>...and others.</li> </ul>"},{"location":"#browser-support","title":"Browser support","text":"<p>Troika's framework and tools are generally intended to support in the same browsers as Three.js does. See the Three.js browser support docs for more details.</p> <p>All source files are ES2015 modules, and can be used un-transpiled in modern browsers supporting <code>&lt;script type=\"module\"&gt;</code>, though you'll probably still want to combine/tree-shake them with a module-aware build pipeline like Webpack or Rollup. For older browsers, ES5-transpiled files are provided.</p>"},{"location":"#origins","title":"Origins","text":"<p>Troika was developed starting in 2016 by the ProtectWise front end engineering team as an internal tool to enable rapid development of interactive 3D and 2D data visualizations in the ProtectWise Visualizer. As it matured and became an essential part of our toolkit, we realized it could be useful to the broader web developer community and decided to release it as an open source project in early 2019.</p> <p>Since then, ProtectWise has been acquired by Verizon Business, where Troika continues to be used for developing new 3D data visualizations on screens and in immersive WebXR environments.</p>"},{"location":"changelog/","title":"Change Log","text":"<p>All notable changes to this project will be documented in this file. See Conventional Commits for commit guidelines.</p>"},{"location":"changelog/#0524-2025-04-02","title":"0.52.4 (2025-04-02)","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>error in Three r175 with custom(Depth|Distance)Material not having setters (78e00b5), closes #357</li> </ul>"},{"location":"changelog/#0523-2024-12-19","title":"0.52.3 (2024-12-19)","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>troika-three-text: Fix error in Safari in BatchedText (2260ba0)</li> </ul>"},{"location":"changelog/#0522-2024-11-21","title":"0.52.2 (2024-11-21)","text":""},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>BatchedText: Fix removing text instances (8bf4bca)</li> <li>BatchedText: Fix texture memory leak (908fe31)</li> </ul>"},{"location":"changelog/#0521-2024-11-21","title":"0.52.1 (2024-11-21)","text":""},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>BatchedText: Fix removing text instances via .remove() (d99549f)</li> </ul>"},{"location":"changelog/#0520-2024-11-11","title":"0.52.0 (2024-11-11)","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>BatchedText: Support remaining visual properties (60c5e93)</li> </ul>"},{"location":"changelog/#0511-2024-11-11","title":"0.51.1 (2024-11-11)","text":""},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>troika-worker-utils: Avoid no-workers log errors when forcing main thread (d396e51), closes #337</li> </ul>"},{"location":"changelog/#0510-2024-11-10","title":"0.51.0 (2024-11-10)","text":""},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>BatchedText: Fix texel read for taller data texture (57f3b0b)</li> <li>troika-three-text: Fix error when first character is whitespace #313 (f71679e)</li> </ul>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>BatchedText: support fillOpacity, and color now sets the <code>diffuse</code> uniform (8f83424)</li> <li>troika-three-text: Add config to disable web worker (86023ec), closes #337</li> <li>troika-worker-utils: Add a handle to force running worker modules on main thread (4f8bc13)</li> </ul>"},{"location":"changelog/#0503-2024-11-01","title":"0.50.3 (2024-11-01)","text":""},{"location":"changelog/#bug-fixes_6","title":"Bug Fixes","text":"<ul> <li>ensure high precision sampling of batched text data texture (f8bd307)</li> <li>Error in derived materials in Three r170 (2402026)</li> </ul>"},{"location":"changelog/#0502-2024-10-21","title":"0.50.2 (2024-10-21)","text":""},{"location":"changelog/#bug-fixes_7","title":"Bug Fixes","text":"<ul> <li>troika-three-text: BatchedText: increase number of batch members (449957d)</li> <li>BatchedText3DFacade: child texts now trigger renders on update (f2c6e0d)</li> </ul>"},{"location":"changelog/#0501-2024-10-12","title":"0.50.1 (2024-10-12)","text":""},{"location":"changelog/#bug-fixes_8","title":"Bug Fixes","text":"<ul> <li>troika-three-text: fix error when using BatchedText material color (7f8c845)</li> <li>troika-three-text: remove DoubleSide double draw hack in favor of forceSinglePass flag (7818d05)</li> </ul>"},{"location":"changelog/#0500-2024-10-11","title":"0.50.0 (2024-10-11)","text":""},{"location":"changelog/#bug-fixes_9","title":"Bug Fixes","text":"<ul> <li>troika-three-utils: add <code>colorspace_fragment</code> (introduced in Three r154) to the list of fragment shaders to process in <code>upgradeShaders()</code> (#325) (9169ebf)</li> <li>change JSDoc for createDerivedMaterial params to be optional (#307) (6969e85)</li> </ul>"},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>troika-three-text: allow overriding text material derivation (9a48e0c)</li> <li>troika-three-text: ALPHA: BatchedText for batching many Text instances in a single draw call (79c9c50)</li> <li>troika-three-utils: add isDerivedFrom method to derived materials (a4a2fcd)</li> </ul>"},{"location":"changelog/#0491-2024-04-09","title":"0.49.1 (2024-04-09)","text":""},{"location":"changelog/#bug-fixes_10","title":"Bug Fixes","text":"<ul> <li>instanced-uniforms-mesh: remove listener on dispose (#284) (336075d)</li> <li>troika-three-text: Fix anchorY bottom-baseline. Closes #309 (3457b03)</li> </ul>"},{"location":"changelog/#0490-2023-10-08","title":"0.49.0 (2023-10-08)","text":""},{"location":"changelog/#bug-fixes_11","title":"Bug Fixes","text":"<ul> <li>support opentype ccmp substitutions (glyph compositions) (1e358b2)</li> </ul>"},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>add support for positioning of diacritic marks (e.g. Thai) (301c34c)</li> </ul>"},{"location":"changelog/#0481-2023-10-02","title":"0.48.1 (2023-10-02)","text":""},{"location":"changelog/#bug-fixes_12","title":"Bug Fixes","text":"<ul> <li>improve font resolution in CJK (8d9ac64)</li> <li>korean/japanese fonts now resolve correctly (207a5e0)</li> </ul>"},{"location":"changelog/#0480-2023-09-09","title":"0.48.0 (2023-09-09)","text":""},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li>troika-three-text: add fallback font loading for full Unicode support (#279) (6fb8061), closes #13 #65</li> </ul>"},{"location":"changelog/#0472-2023-05-15","title":"0.47.2 (2023-05-15)","text":""},{"location":"changelog/#bug-fixes_13","title":"Bug Fixes","text":"<ul> <li>troika-three-utils: pass renderer argument to base material's onBeforeCompile (3a23a8e)</li> <li>troika-three-utils: vertexTransform now handles MAP_UV token introduced in Three r152 (d8c32ed)</li> </ul>"},{"location":"changelog/#0471-2022-12-15","title":"0.47.1 (2022-12-15)","text":""},{"location":"changelog/#bug-fixes_14","title":"Bug Fixes","text":"<ul> <li>troika-three-text: update Typr.ts to get kerning fix (#228) (a45db5d)</li> </ul>"},{"location":"changelog/#0470-2022-12-15","title":"0.47.0 (2022-12-15)","text":""},{"location":"changelog/#bug-fixes_15","title":"Bug Fixes","text":"<ul> <li>add compatibility up to ThreeJS r127 (03640a0)</li> <li>troika-three-text: remove IIFEs for tree-shaking (#224) (2e688f0)</li> <li>Remove incomplete ShaderFloatArray utility to fix build (ddf712a)</li> <li>troika-three-text: include lineGap value from the font in 'normal' line-height calculation (c278118)</li> <li>troika-three-text: update Typr to fix doubled kerning in some fonts (#196) (1fab9a2)</li> <li>troika-three-text: use sTypoAscender/Descender from OS/2 font table if available (f5c244c)</li> <li>troika-three-text: work around Safari&lt;15 bug using SDF canvas as a texture (#199) (fca9aae)</li> </ul>"},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>raise three min version to r125 and fix BufferGeometry references (#225) (f2ef803)</li> <li>three-instanced-uniforms-mesh: add typescript definition file (#217) (cef3564)</li> <li>troika-three-text: add 'top-cap' and 'top-ex' as keywords for anchorY (#193) (c6a10ae)</li> <li>troika-three-text: include capHeight and xHeight font metrics in textRenderInfo (3459fd5)</li> <li>troika-three-text: remove deprecated totalBounds/totalBlockSize properties from textRenderInfo (2b87308)</li> <li>remove custom Thenable polyfill in favor of native promises (7af402e)</li> <li>troika-three-text: remove long-deprecated <code>anchor</code> array property (752e302)</li> </ul>"},{"location":"changelog/#0463-2022-03-11","title":"0.46.3 (2022-03-11)","text":""},{"location":"changelog/#bug-fixes_16","title":"Bug Fixes","text":"<ul> <li>troika-three-text: update Typr to fix doubled kerning in some fonts (#196) (080119a)</li> </ul>"},{"location":"changelog/#0462-2022-03-06","title":"0.46.2 (2022-03-06)","text":""},{"location":"changelog/#bug-fixes_17","title":"Bug Fixes","text":"<ul> <li>troika-three-text: fix SDF texture resizing in Three r136+ (0fab679)</li> </ul>"},{"location":"changelog/#0461-2022-03-05","title":"0.46.1 (2022-03-05)","text":""},{"location":"changelog/#bug-fixes_18","title":"Bug Fixes","text":"<ul> <li>remove console.log (3518689)</li> </ul>"},{"location":"changelog/#0460-2022-03-05","title":"0.46.0 (2022-03-05)","text":""},{"location":"changelog/#features_6","title":"Features","text":"<ul> <li>troika-three-text: add a <code>gpuAccelerateSDF</code> property for opting out of webgl sdf generation (d436ffd)</li> <li>troika-three-text: integrate webgl-sdf-generator for GPU-accelerated SDF generation (b5c9138)</li> </ul>"},{"location":"changelog/#0450-2022-01-02","title":"0.45.0 (2022-01-02)","text":""},{"location":"changelog/#bug-fixes_19","title":"Bug Fixes","text":"<ul> <li>createDerivedMaterial: propagate the base material's customProgramCacheKey (9c8c6b1)</li> </ul>"},{"location":"changelog/#features_7","title":"Features","text":"<ul> <li>troika-three-text: SDFs for all fonts are now stored in the same texture (7e871f7)</li> </ul>"},{"location":"changelog/#performance-improvements","title":"Performance Improvements","text":"<ul> <li>troika-three-text: avoid extra draw call on double sided materials as of Three r130 (6222ef3)</li> <li>troika-three-text: make the glyphColors buffer transferable (c8c92fa)</li> </ul>"},{"location":"changelog/#0440-2021-11-14","title":"0.44.0 (2021-11-14)","text":""},{"location":"changelog/#bug-fixes_20","title":"Bug Fixes","text":"<ul> <li>troika-three-text: fill in missing caret positions when the final glyph is a ligature - #165 (ad2eda6)</li> </ul>"},{"location":"changelog/#0431-alpha0-2021-10-24","title":"0.43.1-alpha.0 (2021-10-24)","text":""},{"location":"changelog/#bug-fixes_21","title":"Bug Fixes","text":"<ul> <li>troika-three-text: fix font parsing failures in iOS Safari (a542b42)</li> </ul>"},{"location":"changelog/#0430-2021-09-20","title":"0.43.0 (2021-09-20)","text":""},{"location":"changelog/#bug-fixes_22","title":"Bug Fixes","text":"<ul> <li>InstancedUniformsMesh: reuse same derived material instance when uniform names change (bd7cea6), closes #154</li> <li>remove warnings about many open worker module requests (164fb8f), closes #156</li> </ul>"},{"location":"changelog/#features_8","title":"Features","text":"<ul> <li>troika-three-text: allow line wrapping after some common non-whitespace chars like hyphens (1b20e34), closes #136</li> <li>troika-worker-utils: add a terminateWorker function (33b8455)</li> <li>don't transpile UMD build files, fixing usage with Three.js r128 (e380b0d), closes #130</li> </ul>"},{"location":"changelog/#performance-improvements_1","title":"Performance Improvements","text":"<ul> <li>troika-three-text: parallelize SDF generation with multiple worker threads (c2bf886)</li> </ul>"},{"location":"changelog/#0420-2021-05-17","title":"0.42.0 (2021-05-17)","text":""},{"location":"changelog/#bug-fixes_23","title":"Bug Fixes","text":"<ul> <li>add three to peerDependencies in all leaf packages (0a11ab6)</li> </ul>"},{"location":"changelog/#features_9","title":"Features","text":"<ul> <li>open up 'three' peer dependency to include future versions (d4a5b23)</li> </ul>"},{"location":"changelog/#0412-2021-05-05","title":"0.41.2 (2021-05-05)","text":""},{"location":"changelog/#bug-fixes_24","title":"Bug Fixes","text":"<ul> <li>update bidi-js for its ES5 build files (49ce5f2)</li> </ul>"},{"location":"changelog/#0411-2021-04-26","title":"0.41.1 (2021-04-26)","text":""},{"location":"changelog/#bug-fixes_25","title":"Bug Fixes","text":"<ul> <li>update bidi-js for fix removing type:module from package.json (394c371)</li> </ul>"},{"location":"changelog/#0410-2021-04-19","title":"0.41.0 (2021-04-19)","text":""},{"location":"changelog/#bug-fixes_26","title":"Bug Fixes","text":"<ul> <li>troika-core: set animation/transition first when using .update() (8ebf59d)</li> <li>troika-three-text: fix Arabic word position letter forms (480ee97)</li> <li>troika-three-text: formatting characters no longer produce visible glyphs (c0d28e8)</li> <li>troika-three-text: more correct impl for character joining types (2ce519a)</li> <li>troika-three-text: prevent mutation of input to worldPositionToTextCoords method (d487b8a)</li> </ul>"},{"location":"changelog/#features_10","title":"Features","text":"<ul> <li>update support up to threejs r127 (5b512f0)</li> <li>troika-three-text: add full bidi text support (3fde850)</li> <li>troika-three-text: simple bidi layout support, using explicit LRO/RLO/PDF chars only (d511655)</li> <li>troika-three-text: very basic support for right-to-left text layout (ce887be)</li> </ul>"},{"location":"changelog/#performance-improvements_2","title":"Performance Improvements","text":"<ul> <li>prune some unused functions out of the Typr build (26e669f)</li> </ul>"},{"location":"changelog/#0400-2021-02-28","title":"0.40.0 (2021-02-28)","text":""},{"location":"changelog/#bug-fixes_27","title":"Bug Fixes","text":"<ul> <li>troika-three-text: fix boundingBox, boundingSphere, and raycasting with curveRadius (7cc7c82), closes #103</li> </ul>"},{"location":"changelog/#features_11","title":"Features","text":"<ul> <li>troika-3d: add <code>initThreeObject</code> lifecycle method to Object3DFacade (230a87d)</li> <li>troika-3d: remove need for manually defining material.instanceUniforms (a234f8c)</li> </ul>"},{"location":"changelog/#0392-2021-02-18","title":"0.39.2 (2021-02-18)","text":""},{"location":"changelog/#bug-fixes_28","title":"Bug Fixes","text":"<ul> <li>troika-three-text: fix shader error in WebGL1 (cdbc7dc), closes #108</li> </ul>"},{"location":"changelog/#0391-2021-02-17","title":"0.39.1 (2021-02-17)","text":""},{"location":"changelog/#bug-fixes_29","title":"Bug Fixes","text":"<ul> <li>troika-three-text: selection rects no longer clip off trailing whitespace (158305c), closes #78</li> </ul>"},{"location":"changelog/#0390-2021-02-15","title":"0.39.0 (2021-02-15)","text":""},{"location":"changelog/#bug-fixes_30","title":"Bug Fixes","text":"<ul> <li>restore compatibility with three versions &lt;0.113.0 by copying MathUtils.generateUUID (35856b5)</li> </ul>"},{"location":"changelog/#features_12","title":"Features","text":"<ul> <li>troika-core: add requestRender method as nicer shortcut (c79254c)</li> <li>troika-three-text: add curveRadius for applying cylindrical curvature (6fdfbbf)</li> <li>troika-three-text: export a function for debugging SDF textures (3fb0c23)</li> <li>troika-three-text: pack SDFs using all 4 color channels, to increase max glyphs in a texture (d236caf)</li> <li>troika-xr: add basic TeleportControls (319ed29)</li> </ul>"},{"location":"changelog/#0381-2021-02-03","title":"0.38.1 (2021-02-03)","text":""},{"location":"changelog/#bug-fixes_31","title":"Bug Fixes","text":"<ul> <li>hoist vertexTransform defs to top of the shader to prevent errors in chained derivations (889ed38)</li> <li>update to support up to Three r125 (4edff04)</li> <li>three-instanced-uniforms-mesh: prevent creation of multiple derived geometries (94a7f67)</li> <li>three-instanced-uniforms-mesh: the derived material is now prototype-chained to its base (bf45d01)</li> <li>troika-worker-utils: properly track open requests count (a01d903)</li> <li>make derived material's customProgramCacheKey function writable (10289dd)</li> <li>troika-three-text: prevent copy() from sharing geometry between instances (8c3ba2d)</li> <li>add new text props to UI blocks (a2d631f)</li> </ul>"},{"location":"changelog/#0380-2021-01-24","title":"0.38.0 (2021-01-24)","text":""},{"location":"changelog/#bug-fixes_32","title":"Bug Fixes","text":"<ul> <li>troika-three-text: allow negative percentages for outlineOffsetX/Y (3a274f0), closes #100</li> </ul>"},{"location":"changelog/#features_13","title":"Features","text":"<ul> <li>move InstancedUniformsMesh to its own three-instanced-uniforms-mesh package (f623b1f)</li> </ul>"},{"location":"changelog/#0370-2021-01-18","title":"0.37.0 (2021-01-18)","text":""},{"location":"changelog/#features_14","title":"Features","text":"<ul> <li>troika-three-text: added inner stroke and outline blur capabilities (e004b9d)</li> <li>add InstancedUniformsMesh class for setting shader uniforms per instance (5fd4d79)</li> </ul>"},{"location":"changelog/#performance-improvements_3","title":"Performance Improvements","text":"<ul> <li>troika-three-text: swap tiny-inflate to fflate for minor speed boost on woff fonts (2ae29fa)</li> </ul>"},{"location":"changelog/#0361-2020-12-16","title":"0.36.1 (2020-12-16)","text":""},{"location":"changelog/#bug-fixes_33","title":"Bug Fixes","text":"<ul> <li>troika-three-text: soften Typr.ts console warnings to debug level (50d951f)</li> <li>troika-xr: destroy WristMountedUI contents when hidden (5589ee2)</li> </ul>"},{"location":"changelog/#0360-2020-12-04","title":"0.36.0 (2020-12-04)","text":""},{"location":"changelog/#bug-fixes_34","title":"Bug Fixes","text":"<ul> <li>fix font parser build scripts (e2d88fa)</li> <li>prevent error in WristMountedUI when gripPose is null (755d560)</li> <li>use combined frustum for XR camera, using setProjectionFromUnion from three.js (ff1b9ae)</li> <li>troika-three-text: fix wrong caret position for collapsed ligature characters (f220035)</li> </ul>"},{"location":"changelog/#features_15","title":"Features","text":"<ul> <li>troika-three-text: fix kerning by updating from Typr.js to Typr.ts (43144cf), closes #70</li> </ul>"},{"location":"changelog/#0350-2020-11-16","title":"0.35.0 (2020-11-16)","text":""},{"location":"changelog/#features_16","title":"Features","text":"<ul> <li>troika-xr: allow configuring framebufferScaleFactor, incl. ratios based on native (f63c160)</li> <li>initial support for spring physics-based transitions (5e05bc8)</li> </ul>"},{"location":"changelog/#0342-2020-11-09","title":"0.34.2 (2020-11-09)","text":""},{"location":"changelog/#bug-fixes_35","title":"Bug Fixes","text":"<ul> <li>troika-3d: prevent tree getting in bad state due to removal of orphanable children (8121425)</li> <li>troika-three-text: dispose the outline material when the base material is disposed (68bd2c8)</li> <li>troika-three-text: fix error when disposing the base material with outlines enabled (73a51f5)</li> </ul>"},{"location":"changelog/#0341-2020-10-20","title":"0.34.1 (2020-10-20)","text":""},{"location":"changelog/#bug-fixes_36","title":"Bug Fixes","text":"<ul> <li>check for process env 'test' (4f7f8f2)</li> <li>check if process is undefined (2b6d56a)</li> </ul>"},{"location":"changelog/#0340-2020-10-19","title":"0.34.0 (2020-10-19)","text":""},{"location":"changelog/#bug-fixes_37","title":"Bug Fixes","text":"<ul> <li>troika-three-text: clipRect is no longer clamped to the text block's bounds (15edbd9)</li> <li>troika-three-text: fix text baseline being positioned too low (596d8ca)</li> <li>troika-worker-utils: pre-transpile the .esm build - issue #84 (98248b6)</li> </ul>"},{"location":"changelog/#features_17","title":"Features","text":"<ul> <li>troika-three-text: expose blockBounds and visibleBounds in textRenderInfo (f3340ec)</li> <li>troika-three-text: text outline and better antialiasing at small sizes (3836809)</li> </ul>"},{"location":"changelog/#performance-improvements_4","title":"Performance Improvements","text":"<ul> <li>micro-optimization of sdf texture insertion loop (995c2a6)</li> </ul>"},{"location":"changelog/#0331-2020-10-02","title":"0.33.1 (2020-10-02)","text":"<p>Note: Version bump only for package troika</p>"},{"location":"changelog/#0330-2020-10-02","title":"0.33.0 (2020-10-02)","text":""},{"location":"changelog/#bug-fixes_38","title":"Bug Fixes","text":"<ul> <li>add \"sideEffects\":false to package.json files to assist treeshaking (61109b2)</li> <li>add PURE annotations to make troika-three-text treeshakeable (8e76b5c)</li> <li>remove redundant \"browser\" and defunct \"jsnext:main\" fields from package.json files (0abec40)</li> <li>troika-three-text: make <code>color</code> prop only apply to that instance when sharing a base material (da0f995)</li> </ul>"},{"location":"changelog/#features_18","title":"Features","text":"<ul> <li>troika-three-text: modifications to the base material are now picked up automatically (fc81d3a)</li> <li>troika-three-utils: add <code>chained</code> option to createDerivedMaterial (2bfaa9c)</li> </ul>"},{"location":"changelog/#0320-2020-09-16","title":"0.32.0 (2020-09-16)","text":""},{"location":"changelog/#bug-fixes_39","title":"Bug Fixes","text":"<ul> <li>troika-three-utils: make derived material methods writable+configurable (4d4bfbc), closes react-spring/drei#121</li> <li>mutate boundingBox and set depth to 0 (1f9b6be)</li> </ul>"},{"location":"changelog/#features_19","title":"Features","text":"<ul> <li>added boundingBox calculation (140e9e8)</li> </ul>"},{"location":"changelog/#0310-2020-08-11","title":"0.31.0 (2020-08-11)","text":""},{"location":"changelog/#bug-fixes_40","title":"Bug Fixes","text":"<ul> <li>troika-3d-ui: remove stray circular import (06be563)</li> <li>move Three.js peerDependency from troika-3d to troika-three-utils (96b6fc8)</li> </ul>"},{"location":"changelog/#features_20","title":"Features","text":"<ul> <li>troika-3d: expose some new props for scene background and color management (5209f66)</li> </ul>"},{"location":"changelog/#0302-2020-07-22","title":"0.30.2 (2020-07-22)","text":""},{"location":"changelog/#bug-fixes_41","title":"Bug Fixes","text":"<ul> <li>troika-three-text: prevent unbound buffer errors when disposing a GlyphsGeometry (e860eac), closes #69 react-spring/drei#62</li> </ul>"},{"location":"changelog/#0301-2020-07-19","title":"0.30.1 (2020-07-19)","text":""},{"location":"changelog/#bug-fixes_42","title":"Bug Fixes","text":"<ul> <li>troika-3d-ui: fix inheritable props on text nodes, and add textIndent (0650c59)</li> <li>troika-three-text: fix changing text length in ThreeJS r117+ (a7ef945), closes #69</li> </ul>"},{"location":"changelog/#0300-2020-07-16","title":"0.30.0 (2020-07-16)","text":""},{"location":"changelog/#bug-fixes_43","title":"Bug Fixes","text":"<ul> <li>troika-worker-utils: decrease main thread message level from warn to log (d7cee6d)</li> </ul>"},{"location":"changelog/#features_21","title":"Features","text":"<ul> <li>troika-three-text: add support for textIndent (b689c0c)</li> <li>extract flexbox layout logic to a new <code>troika-flex-layout</code> package (1b52fc9), closes #53</li> </ul>"},{"location":"changelog/#0290-2020-07-06","title":"0.29.0 (2020-07-06)","text":""},{"location":"changelog/#bug-fixes_44","title":"Bug Fixes","text":"<ul> <li>troika-three-utils: fix program switching when double-deriving materials (89ed2f8)</li> <li>troika-xr: ensure correct initial transform of gltf objects on load (49287f3)</li> </ul>"},{"location":"changelog/#features_22","title":"Features","text":"<ul> <li>troika-3d-text: add sdfGlyphSize option on TextMesh (978ef53), closes #58</li> <li>troika-three-text: promote standalone text to a new <code>troika-three-text</code> package (995f2eb), closes #47</li> </ul>"},{"location":"changelog/#0281-2020-06-17","title":"0.28.1 (2020-06-17)","text":""},{"location":"changelog/#bug-fixes_45","title":"Bug Fixes","text":"<ul> <li>troika-3d-text: don't dispose derived materials on base material switch (3d88475), closes #59</li> <li>troika-3d-text: set correct <code>object</code> in TextMesh raycast intersections (9f3eaa7), closes #62</li> </ul>"},{"location":"changelog/#performance-improvements_5","title":"Performance Improvements","text":"<ul> <li>troika-three-utils: increase chance of program reuse in createDerivedMaterial (56daf65), closes #59</li> </ul>"},{"location":"changelog/#0280-2020-06-09","title":"0.28.0 (2020-06-09)","text":""},{"location":"changelog/#bug-fixes_46","title":"Bug Fixes","text":"<ul> <li>troika-3d-text: fix cloning of TextMesh (13df49b), closes #60</li> <li>troika-3d-text: prevent double-derivation of text material (ef8cffa), closes #59</li> </ul>"},{"location":"changelog/#features_23","title":"Features","text":"<ul> <li>troika-3d-text: add glyphGeometryDetail parameter (1f7a11f), closes #52</li> </ul>"},{"location":"changelog/#0271-2020-06-05","title":"0.27.1 (2020-06-05)","text":""},{"location":"changelog/#bug-fixes_47","title":"Bug Fixes","text":"<ul> <li>troika-3d-text: fix shader error when casting shadows from text (0c9277d)</li> </ul>"},{"location":"changelog/#0270-2020-06-02","title":"0.27.0 (2020-06-02)","text":""},{"location":"changelog/#bug-fixes_48","title":"Bug Fixes","text":"<ul> <li>troika-3d-text: prevent error when transpiling down to es5 (7264b0c), closes #51</li> </ul>"},{"location":"changelog/#features_24","title":"Features","text":"<ul> <li>troika-3d: add three.js r117 to supported version range (2761f39)</li> <li>troika-core: add <code>update</code> convenience method to all facades (7403be1)</li> <li>troika-examples: flexbox example: globe pokes through bg, add scrollable lists (074c620)</li> </ul>"},{"location":"changelog/#0261-2020-05-26","title":"0.26.1 (2020-05-26)","text":""},{"location":"changelog/#bug-fixes_49","title":"Bug Fixes","text":"<ul> <li>troika-worker-modules: silence fallback warning in non-browser environments (3dedb8f)</li> </ul>"},{"location":"changelog/#0260-2020-05-24","title":"0.26.0 (2020-05-24)","text":""},{"location":"changelog/#bug-fixes_50","title":"Bug Fixes","text":"<ul> <li>troika-3d-text: #46 fix error on script load when <code>document</code> not present (1b005ec)</li> </ul>"},{"location":"changelog/#features_25","title":"Features","text":"<ul> <li>examples: add example showing a resizable flexbox layout (8f4d50d)</li> <li>troika-3d-text: experimental <code>colorRanges</code> feature (c4971c3)</li> <li>troika-worker-utils: add main thread fallback when web workers are not allowed (c754d0b)</li> </ul>"},{"location":"changelog/#0250-2020-05-19","title":"0.25.0 (2020-05-19)","text":""},{"location":"changelog/#bug-fixes_51","title":"Bug Fixes","text":"<ul> <li>troika-3d: fix error in InstancingManager on uniforms with default value of 0 (8d2cc83)</li> <li>troika-3d: fix errors due to excessively deep BoundingSphereOctrees (a4b5797), closes #42</li> <li>troika-3d-text: avoid error if something tries to set textMaterial.shadowSide (c09a3c1)</li> </ul>"},{"location":"changelog/#features_26","title":"Features","text":"<ul> <li>troika-3d-text: add events fired on text sync start and completion (3e7d4e0)</li> <li>troika-3d-text: add original input parameters to textRenderInfo object (e1ef963)</li> <li>troika-3d-text: publicly expose getCaretAtPoint and getSelectionRects functions (669b256)</li> </ul>"},{"location":"changelog/#performance-improvements_6","title":"Performance Improvements","text":"<ul> <li>troika-3d-text: improve speed of glyph SDF generation by ~15-20% (3718997)</li> </ul>"},{"location":"changelog/#0241-2020-05-04","title":"0.24.1 (2020-05-04)","text":""},{"location":"changelog/#bug-fixes_52","title":"Bug Fixes","text":"<ul> <li>troika-3d-text: fix error parsing fonts with CFF glyph outlines; fixes #40 (0114ea6)</li> </ul>"},{"location":"changelog/#0240-2020-04-27","title":"0.24.0 (2020-04-27)","text":""},{"location":"changelog/#bug-fixes_53","title":"Bug Fixes","text":"<ul> <li>troika-3d: default Plane and Circle primitives' side and shadowSide to DoubleSide (7704b0a)</li> <li>troika-3d-text: change GlyphSegmentsQuadtree to not use  <code>class</code> (7e4db6c)</li> <li>troika-three-utils: allow use of the timeUniform within glsl functions (7354b9e)</li> </ul>"},{"location":"changelog/#features_27","title":"Features","text":"<ul> <li>troika-3d-text: add <code>preloadFont</code> utility (acedd3c), closes #39</li> <li>troika-3d-text: add enhanced <code>anchorX</code> and <code>anchorY</code> config properties (b58f7b9), closes #38</li> <li>troika-3d-text: add some useful font metrics to textRenderInfo result (c7b14b8)</li> </ul>"},{"location":"changelog/#performance-improvements_7","title":"Performance Improvements","text":"<ul> <li>troika-3d-text: major speed/memory improvement in text layout (1b65b33)</li> <li>troika-3d-text: micro optimizations in text layout (c786397)</li> <li>troika-3d-text: optimize rendering of very long clipped text blocks (c66fbec)</li> </ul>"},{"location":"changelog/#0230-2020-04-16","title":"0.23.0 (2020-04-16)","text":""},{"location":"changelog/#bug-fixes_54","title":"Bug Fixes","text":"<ul> <li>troika-3d-text: selection range rects now honor clipRect, and are instanced (ba86004)</li> <li>troika-3d-ui: allow canceling drag-scroll behavior with e.preventDefault() (eca5f15)</li> <li>troika-3d-ui: prevent sync of text nodes before flex layout finishes (4769cac)</li> <li>troika-three-utils: fragmentColorTransform is now inserted prior to postprocessing chunks (97cd9ac), closes #20</li> </ul>"},{"location":"changelog/#features_28","title":"Features","text":"<ul> <li>troika-3d-ui: add onAfterFlexLayoutApplied hook for <code>FlexNode</code>s (912f95c)</li> <li>troika-3d-ui: allow overriding DatSelect dropdown styles/config (bf78e79)</li> <li>troika-worker-modules: improve rehydration of functions in worker (8f63090), closes #31</li> </ul>"},{"location":"changelog/#performance-improvements_8","title":"Performance Improvements","text":"<ul> <li>troika-3d-ui: make bg/border layers instanced, and move clipping to vertex shader (f7526f4)</li> </ul>"},{"location":"changelog/#0220-2020-04-02","title":"0.22.0 (2020-04-02)","text":""},{"location":"changelog/#bug-fixes_55","title":"Bug Fixes","text":"<ul> <li>examples: fix transparency of globe (8886bc1)</li> <li>examples: make bezier material doublesided (163b3e0)</li> <li>troika-3d-text: letterSpacing no longer applied after newlines (61cb4f8), closes #33</li> <li>troika-xr: fix TargetRay transparency by rendering last w/o depth testing (045ec27)</li> </ul>"},{"location":"changelog/#features_29","title":"Features","text":"<ul> <li>troika-3d-text: add 'orientation' parameter for defining default layout plane (f2c0c76), closes #34</li> </ul>"},{"location":"changelog/#performance-improvements_9","title":"Performance Improvements","text":"<ul> <li>troika-3d-text: move clipping logic from fragment to vertex shader (1accf78)</li> <li>troika-xr: avoid full update pass every frame in WristMountedUI (4a4cd16)</li> <li>troika-xr: avoid setting grip material colors every frame (d3f1246)</li> </ul>"},{"location":"changelog/#0210-2020-03-27","title":"0.21.0 (2020-03-27)","text":""},{"location":"changelog/#features_30","title":"Features","text":"<ul> <li>examples: beziers: add instanceable version of the beziers, and add point light option (0739f4d)</li> <li>troika-3d: instancing now supports custom derived materials (bad5e02)</li> <li>troika-3d: reduce instancing batch size to 128 (dc4bd8a)</li> <li>troika-3d: update ThreeJS support up to r115 (531ff6a)</li> <li>troika-three-utils: added new options for createDerivedMaterial (d67bb4a)</li> <li>troika-three-utils: derived shadow material uniforms are now synced automatically (7843f23)</li> </ul>"},{"location":"changelog/#0200-2020-03-16","title":"0.20.0 (2020-03-16)","text":""},{"location":"changelog/#bug-fixes_56","title":"Bug Fixes","text":"<ul> <li>troika-3d-ui: fix scrollbars sometimes appearing inappropriately (010be47)</li> <li>troika-3d-ui: update children when first exiting clip rect (294f341)</li> </ul>"},{"location":"changelog/#features_31","title":"Features","text":"<ul> <li>troika-3d-ui: allow dat-gui items to declare their own onUpdate (a707fd5)</li> <li>troika-3d-ui: enable shadow casting by UI block bg/border layers (d2c056c)</li> <li>troika-worker-utils: export function for stringifying functions (977634b)</li> </ul>"},{"location":"changelog/#performance-improvements_10","title":"Performance Improvements","text":"<ul> <li>skip updating children of inactive wrist-mounted ui (c1b93f1)</li> </ul>"},{"location":"changelog/#0190-2020-02-28","title":"0.19.0 (2020-02-28)","text":""},{"location":"changelog/#bug-fixes_57","title":"Bug Fixes","text":"<ul> <li>troika-xr: disable buggy experimental clickOnPoke feature (46cff53)</li> </ul>"},{"location":"changelog/#features_32","title":"Features","text":"<ul> <li>examples: example configurators are standardized and work in XR (cec6f63)</li> <li>troika-xr: improved default target ray appearance (3798d9e)</li> </ul>"},{"location":"changelog/#0190-alpha0-2020-02-22","title":"0.19.0-alpha.0 (2020-02-22)","text":""},{"location":"changelog/#bug-fixes_58","title":"Bug Fixes","text":"<ul> <li>honor MeshFacade.autoDispose* when geometry or material changes (f478a47)</li> </ul>"},{"location":"changelog/#features_33","title":"Features","text":"<ul> <li>add a CircleFacade primitive (d73ae87)</li> <li>troika-3d-ui: add DatGuiFacade and supporting widgets (c463198)</li> <li>troika-xr: add WristMountedUI component (74f5b10)</li> </ul>"},{"location":"changelog/#0180-2020-02-21","title":"0.18.0 (2020-02-21)","text":""},{"location":"changelog/#bug-fixes_59","title":"Bug Fixes","text":"<ul> <li>the PlaneFacade's geometry now faces up (cb1bb1b)</li> </ul>"},{"location":"changelog/#features_34","title":"Features","text":"<ul> <li>Add a set of facades for common primitive meshes, using shared geometries and with setters for builtin material properties. (d4b309b)</li> <li>Add memoize function in utils (16efb01)</li> <li>troika-3d: allow passing a Vector3 instance to getCameraPosition (f686483)</li> </ul>"},{"location":"getting-started/examples/","title":"Examples","text":"<p>The troika-examples package contains several example scenes. These are intended to demonstrate a wide range of Troika's capabilities and some interesting techniques that it enables.</p>"},{"location":"getting-started/examples/#viewing-the-examples","title":"Viewing the examples","text":"<p>The examples from the latest master branch are published automatically at https://troika-examples.netlify.com.</p>"},{"location":"getting-started/examples/#running-the-examples","title":"Running the examples","text":"<p>You can run the examples yourself from the source code. First check out the source from GitHub and install the dependencies:</p> <pre><code>git clone https://github.com/protectwise/troika.git\ncd troika\nnpm install\n</code></pre> <p>Then run the examples:</p> <pre><code>npm run examples\n</code></pre> <p>This will build the examples into a bundle and serve up the result at [http://localhost:10001]. Point your browser there and you'll see the examples in action. It will also watch the files for changes so you can fiddle with things and reload the browser to see them in action.</p>"},{"location":"getting-started/setup/","title":"Setup","text":""},{"location":"getting-started/setup/#installation","title":"Installation","text":"<p>Troika is separated into multiple NPM packages depending on your specific needs. For the common case of creating a 3D scene, do:</p> <pre><code>npm install troika-3d\n</code></pre> <p>Additional optional packages can also be installed as needed:</p> <pre><code>npm install troika-2d\nnpm install troika-3d-text\netc...\n</code></pre>"},{"location":"getting-started/setup/#dependencies","title":"Dependencies","text":""},{"location":"getting-started/setup/#threejs","title":"Three.js","text":"<p>The packages related to 3D require <code>three</code> (Three.js) as a peer dependency, which means you will have to declare <code>three</code> as a dependency in your own project. </p> <pre><code>npm install --save three\n</code></pre> <p>The allowed version range for <code>three</code> is open-ended, so you should be able to use any relatively recent version without issues. However, Three.js releases do often contain breaking changes which may introduce incompatibilities in the future. While we try to test against recent <code>three</code> versions on a regular basis, some of these may slip by our notice; if you find one, please open an issue for us.</p>"},{"location":"getting-started/setup/#react","title":"React","text":"<p>Assuming you want to use the React component wrappers (<code>Canvas3D</code> etc.), you'll also need to add <code>react</code> and <code>react-dom</code> to your project's dependencies if not already there:</p> <pre><code>npm install --save react react-dom\n</code></pre> <p>You don't need to do this if you're using Troika without the React wrappers (impressive!) or are just using some of its utilities.</p>"},{"location":"getting-started/setup/#importing","title":"Importing","text":"<p>You should now be able to import from <code>troika-3d</code> as needed...</p>"},{"location":"getting-started/setup/#as-es2015-modules","title":"as ES2015 modules","text":"<pre><code>import {Canvas3D, Object3DFacade} from 'troika-3d'\n</code></pre>"},{"location":"getting-started/setup/#as-commonjs-modules","title":"as CommonJS modules","text":"<pre><code>const {Canvas3D, Object3DFacade} = require('troika-3d')\n</code></pre>"},{"location":"getting-started/setup/#as-globals","title":"as globals","text":"<p>If you are not using a module-aware build pipeline, Troika's UMD bundles expose globals you can use instead; you'll need to include the proper dependencies manually.</p> <p>Note: This usage pattern is not well tested; please report bugs with it.</p> <pre><code>&lt;script&gt;\nvar Canvas3D = troika_3d.Canvas3D;\nvar Object3DFacade = troika_3d.Object3DFacade;\n//...\n&lt;/script&gt;\n</code></pre>"},{"location":"getting-started/setup/#source-code-checkout","title":"Source Code Checkout","text":"<p>If you want to work with the source code or run the examples locally, clone it from the GitHub repository:</p> <pre><code>git clone https://github.com/protectwise/troika.git\ncd troika\nnpm install\n</code></pre>"},{"location":"three-instanced-uniforms-mesh/","title":"InstancedUniformsMesh","text":"<p>This package provides a <code>InstancedUniformsMesh</code> class which extends Three.js's <code>InstancedMesh</code> to allow its material's shader uniforms to be set individually per instance. It behaves just like <code>InstancedMesh</code> but exposes a new method:</p> <pre><code>mesh.setUniformAt(uniformName, instanceIndex, value)\n</code></pre> <p>When you call <code>setUniformAt</code>, the geometry and the material's shaders will be automatically upgraded behind the scenes to turn that uniform into an instanced buffer attribute, filling in the other indices with the uniform's default value. You can do this for any uniform of type <code>float</code>, <code>vec2</code>, <code>vec3</code>, or <code>vec4</code>. It works both for built-in Three.js materials and also for any custom ShaderMaterial.</p> <p>For example, here is how you could set random <code>emissive</code> and <code>metalness</code> values for each instance using a <code>MeshStandardMaterial</code>:</p> <pre><code>import { InstancedUniformsMesh } from 'three-instanced-uniforms-mesh'\n\nconst count = 100\nconst mesh = new InstancedUniformsMesh(\nsomeGeometry,\nnew MeshStandardMaterial(),\ncount\n)\nconst color = new Color()\nfor (let i = 0; i &lt; count; i++) {\nmesh.setMatrixAt(i, someMatrixValue)\nmesh.setUniformAt('metalness', i, Math.random())\nmesh.setUniformAt('emissive', i, color.set(Math.random() * 0xffffff))\n}\n</code></pre> <p>While this is obviously useful for Three.js's built in materials, it really shines with custom shaders. Just declare any configurable parameters as uniforms in your custom shader, and then you can use that either on a single non-instanced <code>Mesh</code> by setting the material's uniforms directly, or instance it using <code>InstancedUniformsMesh</code> by calling <code>setUniformAt</code>. Your shader doesn't need to change at all to support the instancing! </p> <p>Note: Calling <code>setUniformAt</code> automatically marks the underlying buffer attributes for upload, so unlike <code>setMatrixAt</code> or <code>setColorAt</code> you don't need to set <code>needsUpdate</code> manually.</p>"},{"location":"three-instanced-uniforms-mesh/#value-types","title":"Value Types","text":"<p>The type of the <code>value</code> argument should match the type of the uniform defined in the material's shader:</p> For a uniform of type: Pass a value of this type: float Number vec2 <code>THREE.Vector2</code> vec3 <code>THREE.Vector3</code> or <code>THREE.Color</code> vec4 <code>THREE.Vector4</code> mat3 (ThreeJS r132+ only) <code>THREE.Matrix3</code> mat4 (ThreeJS r132+ only) <code>THREE.Matrix4</code>"},{"location":"three-instanced-uniforms-mesh/#resetting-to-defaults","title":"Resetting to defaults","text":"<p>If you have set instance-specific values for a given uniform but you want to revert all those to the single original uniform value, you can call:</p> <pre><code>mesh.unsetUniform(uniformName)\n</code></pre>"},{"location":"three-instanced-uniforms-mesh/#examples","title":"Examples","text":"<ul> <li> <p>Instanced spheres with varying metalness/roughness (uses react-three-fiber)</p> </li> <li> <p>Instanced beziers with varying control points (plain Three.js + BezierMesh)</p> </li> </ul>"},{"location":"troika-2d/","title":"Troika 2D - Overview","text":"<p>Documentation to come...</p>"},{"location":"troika-2d/html-overlays/","title":"HTML Overlays","text":"<p>Documentation to come...</p>"},{"location":"troika-2d/objects/","title":"Interactivity in 2D","text":"<p>Documentation to come...</p>"},{"location":"troika-3d/","title":"Troika 3D - Overview","text":"<p>The <code>troika-3d</code> package provides the ability to create interactive 3D scenes with Troika's declarative framework. It uses Three.js as its underlying WebGL renderer, giving you access to Three's full set of tools and its excellent community.</p> <p>It does very little to abstract away from Three's API, and you will need to know the Three.js object model well to use it. But through its primary facade class, <code>Object3DFacade</code>, it gives you a straightforward way to:</p> <ul> <li>componentize your 3D objects</li> <li>manage them all together declaratively</li> <li>apply automatic transitions and animations</li> <li>make them interactive with pointer events</li> <li>optimize for the best frame rate</li> </ul> <p> </p>"},{"location":"troika-3d/#installation","title":"Installation","text":"<pre><code>npm install troika-3d\n</code></pre> <p>You will also need to install a compatible version of Three.js. See the Setup page for details about Three.js versions.</p> <pre><code>npm install three\n</code></pre>"},{"location":"troika-3d/#next-steps","title":"Next Steps","text":"<p>If you haven't already, you should familiarize yourself with the Troika framework's Core Concepts. Troika 3D builds on those.</p> <p>Then, move on to Creating a 3D Scene and Adding 3D Objects to it.</p>"},{"location":"troika-3d/html-overlays/","title":"HTML Overlays","text":"<p>Documentation to come...</p>"},{"location":"troika-3d/instancing/","title":"GPU Instancing","text":"<p>Troika's instancing abstraction is super powerful. Documentation to come...</p>"},{"location":"troika-3d/interactivity-and-events/","title":"Interactivity and Events in 3D","text":"<p>Objects in 3D scenes inherit all the useful event handling features from Troika Core's event system. See the core Interactivity and Events documentation for what it can do.</p> <p>Troika 3D also adds some enhancements, which are described here:</p>"},{"location":"troika-3d/interactivity-and-events/#raycasting","title":"Raycasting","text":"<p>Any <code>Object3DFacade</code> with a pointer-related event listener, a <code>pointerStates</code> property, or <code>pointerEvents:true</code> will be raycasted in the scene and, if that raycast intersects, will dispatch a corresponding event like \"mouseover\", which bubbles up the facade tree.</p> <p>The event object that is dispatched will always have a <code>ray</code> property holding a Three.js <code>Ray</code>, which will be set from the mouse position on screens, or from a pointer ray in WebXR, etc. as appropriate. Because the event can come from different sources, it's safer for handler code to rely on that <code>ray</code> rather than trying to use <code>e.clientX</code> etc.</p> <p>The raycasting process is highly optimized behind the scenes using an octree prefilter. See the performance doc for details.</p>"},{"location":"troika-3d/objects/","title":"Adding 3D Objects","text":"<p>So you've got a 3D scene with a camera and now you want to add some 3D objects to it, naturally!</p> <p>Like every other object in Troika, 3D object types are defined by Facades, and configured by scene descriptors. To help you out, The <code>troika-3d</code> package provides some Facade types that know how to manage and optimize a tree of Three.js objects. They all use <code>Object3DFacade</code> as their foundation:</p>"},{"location":"troika-3d/objects/#object3dfacade","title":"Object3DFacade","text":"<p>Any Three.js <code>Object3D</code> in your scene will, naturally, be represented by an <code>Object3DFacade</code>. This is a specialized Facade base class which knows some things about dealing with <code>Object3D</code>, such as:</p> <ul> <li>Properties for positioning/rotation/scaling, with automatic optimized matrix updates</li> <li>Raycasting methods, with related optimizations</li> <li>Methods for querying world positions, camera position, etc.</li> <li>Various shortcut passthrough properties</li> </ul> <p>This is just a base class, so in most cases it will be more convenient for you to use a <code>MeshFacade</code> or a <code>Group3DFacade</code>, but all the properties and methods described here will apply to those as well.</p>"},{"location":"troika-3d/objects/#construction","title":"Construction","text":"<p>Every concrete subclass of <code>Object3DFacade</code> must create a Three.js <code>Object3D</code> instance (a <code>Mesh</code>, <code>Line</code>, <code>Group</code>, etc.) that will become the backing implementation for that facade. It will be stored as <code>this.threeObject</code> for use later on, and will be guaranteed to never change during the lifetime of the facade instance. This strict contract makes it easier to reason about in other logic, and allows Troika to apply certain optimizations it couldn't otherwise.</p> <p>To create the <code>Object3D</code>, you can either:</p> <p>1) Implement the <code>initThreeObject()</code> method and return the <code>Object3D</code> instance, or 2) Override the <code>constructor</code> and pass the <code>Object3D</code> as a second argument to <code>super(parent, obj3D)</code></p> <p>Generally the first method is preferred, though if you're already overriding the constructor for other purposes then the second method can be easier.</p> <p>An example using <code>initThreeObject()</code>:</p> <pre><code>import { Object3DFacade } from 'troika-3d'\nimport { Mesh, BoxGeometry, MeshStandardMaterial } from 'three'\n\n// It's often to define a singleton geometry instance that can be used\n// across all instances of this object type:\nconst geometry = new BoxGeometry()\n\nclass MyObject extends Object3DFacade {\ninitThreeObject() {\nreturn new Mesh(geometry, new MeshStandardMaterial())\n}\n\nafterUpdate() {\n// The Mesh created above can be referenced as `threeObject`:\nthis.threeObject.material.color.set(this.color)\nsuper.afterUpdate()\n}\n}\n</code></pre> <p>Or an example <code>constructor</code> override:</p> <pre><code>//...\n\nclass MyObject extends Object3DFacade {\nconstructor(parent) {\nconst threeObj = new Mesh(geometry, new MeshStandardMaterial())\nsuper(parent, threeObj)\n}\n\n// ...\n}\n</code></pre>"},{"location":"troika-3d/objects/#properties","title":"Properties","text":"<p>The following properties are supported by all <code>Object3DFacade</code> subclasses:</p> <ul> <li> <p><code>threeObject</code> - This is a reference to the Three.js <code>Object3D</code> instance that was created in the <code>initThreeObject</code> method or the constructor. This will be a stable reference, never changing during the facade instance's lifetime. It will be deleted upon destruction, however.</p> </li> <li> <p><code>parent</code> - This is a reference to the parent Facade instance. This will be a stable reference, never changing during the facade instance's lifetime. It will be deleted upon destruction, however.</p> <p>To access the nearest parent Object3D, use <code>this.threeObject.parent</code> instead.</p> </li> <li> <p><code>castShadow</code>, <code>receiveShadow</code> - Shortcuts to setting these shadow-related properties on the threeObject.</p> </li> <li><code>renderOrder</code> - Shortcut to the <code>renderOrder</code> property on the threeObject.</li> <li><code>visible</code> - Shortcut to the <code>visible</code> property on the threeObject.</li> <li><code>raycastSide</code> - Lets you force a different <code>side</code> than that of the material during mesh raycasting. Should be set to <code>FrontSide</code>|<code>BackSide</code>|<code>DoubleSide</code>, or <code>null</code> to use the material's <code>side</code>.</li> </ul>"},{"location":"troika-3d/objects/#local-transform-properties","title":"Local Transform Properties","text":"<p>These properties expose the Three object's <code>position</code>, <code>scale</code>, <code>quaternion</code>, and <code>rotation</code> objects' values. They are synced to those objects, but exposing them as flat Facade properties makes it easy to animate them and to track their changes for optimized matrix updating.</p> <ul> <li> <p><code>x</code>, <code>y</code>, <code>z</code> - These set the object's position transform in local space.</p> </li> <li> <p><code>scale</code>, <code>scaleX</code>, <code>scaleY</code>, <code>scaleZ</code> - These set the object's scale transform in local space. The <code>scale</code> shortcut sets all the directional scales to the same value.</p> </li> <li> <p><code>rotateX</code>, <code>rotateY</code>, <code>rotateZ</code>, <code>rotateOrder</code> - These set the object's Euler rotation transform in local space.</p> </li> <li> <p><code>quaternionX</code>, <code>quaternionY</code>, <code>quaternionZ</code>, <code>quaternionW</code> - These set the object's Quaternion rotation transform in local space.</p> </li> </ul>"},{"location":"troika-3d/objects/#methods","title":"Methods","text":"<ul> <li> <p><code>getWorldPosition(Vector3?)</code> - Gets the world position of this object's origin. If a Vector3 is passed, the position will be written into that object, otherwise it will return a new Vector3. Assuming this is called in the facade's update phase, the world matrix will be up-to-date.</p> </li> <li> <p><code>getProjectedPosition(x, y, z)</code> - Given x/y/z coordinates in local space, calculates the projected view space coordinates. Returns a Vector3 where <code>x</code> and <code>y</code> are the view position in screen pixels, and <code>z</code> is the worldspace distance from the camera.</p> </li> <li> <p><code>getCameraPosition(Vector3?)</code> - Gets the current world position of the camera. If a Vector3 is passed, the position will be written into that object, otherwise it will return a new Vector3.</p> </li> <li> <p><code>getCameraDistance()</code> - Returns the current distance in world units between this object's origin and the camera.</p> </li> <li> <p><code>getCameraFacade()</code> - Returns a reference to the <code>CameraFacade</code> instance. This can be used to access low-level info about the camera such as its various matrices and projection attributes, but be careful not to make modifications to the camera as that can lead to things getting out of sync.</p> </li> <li> <p><code>getSceneFacade()</code> - Returns a reference to the <code>SceneFacade</code> instance. This can be useful in a pinch, but it's usually better to pass any required scene-level values to each facade.</p> </li> <li> <p><code>updateMatrices()</code> - Updates the underlying threeObject's <code>matrix</code> and <code>matrixWorld</code> to the current state of this object's transform and those of its ancestors, if necessary. This bypasses the <code>updateMatrix</code> and <code>updateMatrixWorld</code> methods of the Three.js objects with a more efficient approach that doesn't require traversing the entire tree prior to every render. As long as this is called from the <code>afterUpdate</code> lifecycle method or later, it can be safely assumed that the world matrices of all ancestors have already been similarly updated, so the result should always be accurate.</p> </li> <li> <p><code>markWorldMatrixDirty()</code> - If the <code>threeObject.matrixWorld</code> is modified manually instead of via the local transform properties, as is sometimes required for more complex transformations, you should call this to update the internal caches and signal that child objects should update their own matrices to match.</p> </li> </ul>"},{"location":"troika-3d/objects/#meshfacade","title":"MeshFacade","text":"<p>You will likely most often want to use <code>MeshFacade</code> instead of creating your own <code>Object3DFacade</code> subclass. This prevents you from having to implement your own constructor override, creating a <code>Mesh</code> instance automatically, and adds some additional helpful facade properties for you.</p>"},{"location":"troika-3d/objects/#properties_1","title":"Properties","text":"<ul> <li> <p><code>geometry</code> - Lets you set the mesh's <code>geometry</code>. You'll usually only do this once, but you can also change it on the fly, e.g. for choosing an LOD based on camera distance.</p> </li> <li> <p><code>material</code> - Lets you change the mesh's <code>material</code>. In addition to accepting Three.js Material instances, it also supports the following string aliases for common built-in Three.js materials: \"basic\", \"depth\", \"distance\", \"lambert\", \"matcap\", \"normal\", \"phong\", \"physical\", \"standard\", and \"toon\". Defaults to \"standard\" for creating a <code>MeshStandardMaterial</code>.</p> </li> <li> <p><code>material.xyz</code> - For all of the above built-in material types, MeshFacade automatically creates setters for the properties of those materials. For example in a scene descriptor object:</p> <pre><code>{\nfacade: MeshFacade,\n//...\nmaterial: 'standard',\n'material.color': 0x3366cc,\n'material.metalness': 0.8,\n'material.roughness': 0.5\n}\n</code></pre> <p>Notice how you must include quotes around the material properties since they include dots in them.</p> </li> <li> <p><code>autoDisposeGeometry</code> - If set to <code>true</code>, the geometry's <code>dispose</code> method will automatically be called when the facade is destroyed, and when swapping it out with another geometry. </p> <p>This can be useful for freeing resources for large geometries that only appear once, but can hurt performance if there are multiple instances of that geometry in the scene or if it is removed and re-added later. In many cases, especially for simpler geometries, it's better to avoid disposal; therefore this defaults to <code>false</code>.</p> </li> <li> <p><code>autoDisposeMaterial</code> - If set to <code>true</code>, the material's <code>dispose</code> method will automatically be called when the facade is destroyed, and when swapping it out with another material. This is almost never needed, so it defaults to <code>false</code>.</p> <p>If your material uses a <code>Texture</code> that needs to be disposed, you will need to do that yourself, e.g. in a subclass that overrides the <code>destructor</code> method.</p> </li> </ul>"},{"location":"troika-3d/objects/#group3dfacade","title":"Group3DFacade","text":"<p>This is a specialized <code>Object3DFacade</code> for Three.js <code>Group</code> objects.</p> <p>It's basically just an <code>Object3DFacade</code> that already creates a <code>Group</code> object in its constructor, though it also applies some additional optimizations. You can use it directly in scene descriptors, with any child objects as its <code>children</code>:</p> <pre><code>import { Group3DFacade } from 'troika-3d'\n\n//...descriptor in scene:\n{\nfacade: Group3DFacade,\nz: -1,\nscale: 0.5,\nchildren: [\n{\nfacade: DonutFacade,\nx: -1\n},\n{\nfacade: PyramidFacade,\nx: 1\n}\n]\n}\n</code></pre> <p>It can also be useful to extend a custom Facade class from <code>Group3DFacade</code>, for example to implement some controller logic or to manage a collection of rendered objects as a single component.</p> <pre><code>class GaugeFacade extends Group3DFacade {\n/** @type number - from 0 to 100 */\nvalue = 0\n\ndescribeChildren() {\nreturn [\n{\nkey: 'ring',\nfacade: GaugeRing, //another custom facade\npercent: this.value,\ncolor: valueToColor(this.value),\nradius: 0.1,\ntransition: {percent: true} //animate ring changes\n},\n{\nkey: 'label',\nfacade: Text3DFacade, //see troika-3d-text package\nanchorX: 'center',\nanchorY: 'middle',\nfontSize: 0.05,\ntext: `${this.value}%`\n}\n]\n}\n}\n</code></pre> <p>Also, since pointer events bubble, you can add listeners on a Group3DFacade to respond to raycasting events on any of its descendant objects. Just remember that you may need to set <code>pointerEvents: true</code> on those objects to trigger raycasting for them.</p>"},{"location":"troika-3d/objects/#instanceable3dfacade","title":"Instanceable3DFacade","text":"<p>This is a special kind of <code>Object3DFacade</code> that renders its underlying object using GPU instancing along with all other <code>Instanceable3DFacade</code> instances of the same type, but behaves as its own component instance in terms of how it's configured and handles events. See the page on instancing for details.</p>"},{"location":"troika-3d/performance/","title":"Performance Optimization","text":"<p>Compared to raw Three.js, Troika automatically performs several optimizations to reduce the CPU time spent on each render frame. Here are the most impactful:</p>"},{"location":"troika-3d/performance/#unnecessary-renders","title":"Unnecessary renders","text":"<p>The typical setup for Three.js rendering involves an animation loop that recursively calls <code>requestAnimationFrame</code> and re-renders the entire scene on every frame, regardless of whether anything in the scene has actually changed. This causes unnecessarily high CPU/GPU usage and battery drain for scenes that are largely static.</p> <p>Troika controls when the Three.js scene is re-rendered, only doing so when:</p> <ul> <li>The scene is updated</li> <li>A facade <code>animation</code> or <code>transition</code> is running</li> <li>A facade changes properties due to <code>pointerStates</code> interactions</li> <li>A facade indicates that it requires a re-render by calling its <code>requestRender</code> method</li> </ul>"},{"location":"troika-3d/performance/#matrix-calculations","title":"Matrix calculations","text":"<p>By default, Three.js takes a brute-force approach to calculating the world matrices of objects: on every frame it traverses the entire scene graph and for each <code>Object3D</code> it both composes a local transform <code>matrix</code> and multiplies it with the parent to get its <code>worldMatrix</code>. This can quickly add up to be the primary CPU user in large scenes, even if no objects are moving.</p> <p>The Object3D.matrixAutoUpdate and Scene.autoUpdate flags do allow you to limit the brute-force matrix calculations, but then performing those updates manually (a tedious and error-prone process) becomes the author's responsibility.</p> <p>Troika gives you the best of both worlds by automatically setting <code>scene.autoUpdate=false</code> and <code>threeObject.matrixAutoUpdate=false</code> for every object it manages, and then taking care of recalculating the local and/or world matrices only when necessary. More specifically:</p> <ul> <li>The local <code>matrix</code> is only recomposed when one of the properties that may affect it (<code>x</code>/<code>y</code>/<code>z</code>/<code>rotateX|Y|Z</code>/<code>scaleX|Y|Z</code>) changes.</li> <li>The <code>worldMatrix</code> is only remultiplied when the local <code>matrix</code> or the <code>worldMatrix</code> of its parent have changed.</li> </ul> <p>This results in the time taken by matrix calculations dropping to nearly zero when objects are not moving, even for very large scenes.</p> <p>NOTE: This is perhaps the single most valuable optimization Troika performs. Not only does it nearly remove the per-frame matrix update cost, but knowing exactly when any object's matrix is changed opens up the possibility for other optimizations like maintaining a raycasting octree and more flexible GPU instancing abstractions.</p> <p>It is our goal to attempt extracting this matrix management capability from Troika's framework code, allowing it to be used in any Three.js scene, even if managed by another framework.</p>"},{"location":"troika-3d/performance/#raycasting","title":"Raycasting","text":"<p>The standard method for picking 3D objects with a pointer (mouse/touch/etc.) is to determine a ray for that pointer and then search the scene's objects for those that intersect that ray, also known as \"raycasting.\" Three.js provides a Raycaster class for that purpose; however the usual approach is to iterate through all the objects in the scene and calculate the ray intersection for each. For scenes with many objects this can quickly add up and produce frame drops while raycasting.</p> <p>Troika optimizes this process by maintaining an internal Octree of the bounding spheres for every object in the scene, and then using that as a fast pre-filter to skip ray intersection calculations for objects that have no possibility of matching.</p> <p>TODO: note about how to specify bounding sphere for use in the octree when using custom shaders that manipulate the vertices</p>"},{"location":"troika-3d/performance/#scene-graph-traversal","title":"Scene graph traversal","text":"<p>On every render frame Three.js traverses the entire scene graph, deciding what to do with each type of object in the tree, if anything. This means it does several type checks for every object, even those that have no visible representation in the scene, such as empty <code>Group</code>s or the invisible objects used for tracking HTML Overlay positions.</p> <p>To help with this, Troika performs the following optimizations for those objects it manages which it knows have no visible rendering:</p> <ul> <li>It sets <code>threeObject.layers.mask = 0</code>, which makes the renderer skip its per-frame type checks.</li> <li>If the object has no children, it is not added to the Three.js scene graph at all.</li> </ul> <p>Authors may also set the custom property <code>threeObject.isRenderable = false</code> to gain these same optimizations for their own invisible objects. The proeprty must be set prior to passing the object to the <code>Object3DFacade</code>'s constructor.</p>"},{"location":"troika-3d/performance/#batch-object-removal","title":"Batch object removal","text":"<p>Removing large numbers of scene objects from their parents can be slow in Three.js due to how it splices the parent's <code>children</code> array for each object removed. Troika batches the removal of many children into a single operation to speed this up.</p>"},{"location":"troika-3d/scenes/","title":"Creating a 3D Scene","text":"<p>So you want to create a 3D scene! Let's go.</p> <p>Note: Currently the only entry point provided is a React component called <code>&lt;Canvas3D&gt;</code>. This assumes your application uses React, and you're adding a Troika 3D canvas into it. In the future we plan to provide entry points for other frameworks, a web component, and a pure JS entry point function. Contributions are welcome.</p>"},{"location":"troika-3d/scenes/#canvas3d","title":"Canvas3D","text":"<p>The <code>&lt;Canvas3D&gt;</code> React component is your starting point. This component creates a WebGL canvas and other required DOM elements, takes configuration props for the Three.js renderer, and accepts descriptors for a camera, lights, and all your scene's objects.</p>"},{"location":"troika-3d/scenes/#configuration-props","title":"Configuration Props","text":"<ul> <li> <p><code>width</code> and <code>height</code> - These are required to set the size of the canvas. If you want to have the canvas expand to the size of its container, then you'll need to use something like <code>useDimensions</code> in your outer React component to measure the available size.</p> </li> <li> <p><code>antialias</code> - If set, enables antialiasing.</p> </li> <li> <p><code>background</code> - Sets the Three.js scene's <code>background</code></p> </li> <li> <p><code>canvasStyle</code> - An optional object holding CSS style properties to apply to the <code>&lt;canvas&gt;</code> element. Defaults to <code>{width: '100%', height: '100%'}</code>.</p> </li> <li> <p><code>className</code> - An optional <code>class</code> attribute that will be applied to the wrapper element. Defaults to <code>\"troika\"</code>.</p> </li> <li> <p><code>continuousRender</code> - If set, frames will be rendered continuously, instead of the default behavior of only rendering when something in the scene requires it.</p> </li> <li> <p><code>environment</code> - Sets the Three.js scene's <code>environment</code></p> </li> <li> <p><code>onBackgroundClick</code> - A function that will be called when the user clicks the scene's background without hitting an object.</p> </li> <li> <p><code>outputEncoding</code> - Sets the Three.js renderer's <code>outputEncoding</code></p> </li> <li> <p><code>pixelRatio</code> - Sets the pixel ratio for the canvas. Defaults to the current screen's reported <code>window.devicePixelRatio</code>.</p> </li> <li> <p><code>rendererClass</code> - Lets you override the Three.js <code>WebGLRenderer</code> class with a custom subclass of your own.</p> </li> <li> <p><code>stats</code> - If set, statistics about the frame rate and number of things rendered will be displayed. Useful for debugging.</p> </li> <li> <p><code>toneMapping</code> - Sets the Three.js renderer's <code>toneMapping</code></p> </li> <li> <p><code>worldFacade</code> - Lets you override the <code>World3DFacade</code> class used as the main world controller with a custom subclass of your own.</p> </li> <li> <p><code>worldProps</code> - An object holding properties that will be copied onto the <code>worldFacade</code>.</p> </li> </ul>"},{"location":"troika-3d/scenes/#scene-structure-props","title":"Scene Structure Props","text":""},{"location":"troika-3d/scenes/#lights","title":"<code>lights</code>","text":"<p>This should be set to an array of descriptor objects describing the main lights in your scene. You can choose the type of light with the <code>type</code> property and one of the following strings: \"ambient\", \"directional\", \"spot\", \"point\", or \"hemisphere\". You can also set the <code>facade</code> property to use a custom facade wrapper.</p> <pre><code>lights={[\n{type: 'ambient', color: 0x999999},\n{type: 'directional', x: 1, y: 1, z: 1},\n{facade: WanderingPointLight, color: 0xff0000}\n]}\n</code></pre>"},{"location":"troika-3d/scenes/#camera","title":"<code>camera</code>","text":"<p>This should be set to a descriptor object describing the type of camera, its projection parameters, position, etc. It defaults to a <code>PerspectiveCamera3DFacade</code> with aspect ratio based on the canvas's dimensions.</p> <pre><code>camera={{\nx: 5,\nrotateY: -Math.PI / 2,\nfov: 75,\nfar: 30\n}}\n</code></pre> <pre><code>import { OrthographicCamera3DFacade } from 'troika-3d'\n\n//...\n\ncamera={{\nfacade: OrthographicCamera3DFacade,\nz: 1,\ntop: height / 2,\nbottom: -height / 2,\nleft: 0,\nright: width\n}}\n</code></pre> <pre><code>camera={{\nfacade: OrbitingCameraFacade //a custom facade with orbiting movement\n}}\n</code></pre> <p>Since this camera config is a descriptor object, it can also be given animations and transitions.</p> <pre><code>camera={{\nx: currentPos.x,\nz: currentPos.z,\nrotateY: currentPos.angle,\n// Smoothly transition between positions:\ntransition: {\nx: true,\nz: true,\nrotateY: true\n},\n// Bob in place:\nanimation: {\nfrom: { y: 1.4 },\nto: {y: 1.5},\nduration: 3000,\ndirection: 'alternate',\niterations: Infinity\n}\n}}\n</code></pre>"},{"location":"troika-3d/scenes/#objects","title":"<code>objects</code>","text":"<p>This is an array of descriptor objects describing all the things in your scene. See the page on Adding 3D Objects for details.</p> <pre><code>objects={[\n{\nkey: 'mainGroup',\nz: -2,\nfacade: Group3DFacade,\nchildren: [\n{\nfacade: SphereFacade,\nradius: 0.25,\nx: -1,\n'material.color': 0x3366cc\n},\n{\nfacade: CustomObjectFacade,\nx: 1\n}\n]\n}\n]}\n</code></pre>"},{"location":"troika-3d/scenes/#fog","title":"<code>fog</code>","text":"<p>This is an object holding config properties for a Three.js <code>Fog</code> or <code>FogExp2</code>. It is not a proper Troika descriptor; if it has a <code>density</code> property it will create a <code>FogExp2</code> otherwise it will create a <code>Fog</code>.</p>"},{"location":"troika-3d/text/","title":"3D Text","text":"<p>The <code>troika-3d-text</code> package provides a <code>Text3DFacade</code> for high quality text rendering in Troika 3D scenes, using signed distance fields (SDF) and antialiasing using standard derivatives.</p> <p>The bulk of its implementation has been extracted to the <code>troika-three-text</code> package which allows it to be used in any Three.js project without any Troika framework dependencies. For the most part <code>Text3DFacade</code> is a passthrough to a <code>Text</code> object from that package. See the troika-three-text docs for the available properties, all of which can be set on <code>Text3DFacade</code>.</p> <pre><code>import { Text3DFacade } from 'troika-3d-text'\n\n{\nkey: 'text',\nfacade: Text3DFacade,\nfont: 'https://url/of/font.woff',\ntext: 'Hello World!',\nfontSize: 0.1,\ncolor: 0xccccff\n//...other props\n}\n</code></pre> <p>This text rendering engine is also used by the <code>troika-3d-ui</code> package to perform text layout measurements for flexbox layout as well as the final rendering.</p>"},{"location":"troika-3d-ui/","title":"3D User Interfaces","text":"<p>The <code>troika-3d-ui</code> package allows creating flexbox user interfaces in 3D scenes. It behaves largely like CSS flexbox, but renders in WebGL so it can make use of Three.js materials, can include fully 3D objects within its layout, and remains functional in WebXR.</p> <p>It uses the text layout engine from <code>troika-3d-text</code>, so the flexbox layout can auto-size elements based on the size of their text content, and the final rendering includes high quality antialiased text.</p> <p>Examples:</p> <ul> <li> <p>Example 1</p> </li> <li> <p>Example 2</p> </li> </ul> <p>More documentation to come.</p>"},{"location":"troika-core/animations-and-transitions/","title":"Animations and Transitions","text":"<p>Troika has built-in support for declarative transitions and animations on the properties of any Facade, controlled via <code>transition</code> and <code>animation</code> properties in the scene descriptors. These generally work very much like CSS transitions and CSS animations, so they should be very familiar to web developers.</p> <p>Note: These transitions and animations are driven by the troika-animation package. Facade classes are automatically extended to intercept property changes and apply transitions when needed.</p>"},{"location":"troika-core/animations-and-transitions/#transitions","title":"Transitions","text":"<p>Any descriptor can be given a <code>transition</code> property to automatically intercept changes to certain properties and animate from their previous values to their new values. </p> <p>The <code>transition</code> property should be an object with transitionable property names as keys, and transition specs as values. Those specs can either be objects describing the transition parameters, or <code>true</code> for a default transition.</p> <p>Troika supports both traditional duration-based transitions, like CSS, but also supports \"spring\" animations ala react-spring. Spring animations can often give a more natural feel and behave better when target values change repeatedly during transition, but duration-based transitions can be more predictable. Use the approach that fits your case.</p> <p>A basic example of a descriptor object that defines transitions for its <code>x</code>, <code>y</code>, and <code>z</code> properties:</p> <pre><code>{\nfacade: MyObject,\nx: xVal,\ny: yVal,\nz: zVal,\ntransition: {\nx: true, // uses a default duration-based transition\ny: 'spring', //uses a default spring-based transition\nz: { //detailed transition parameters:\nduration: 500,\neasing: 'easeOutExpo'\n}\n}\n}\n</code></pre> <p>When this descriptor is next applied with new values for <code>x</code>, <code>y</code>, and <code>z</code>, those values will be individually transitioned based on their configured parameters. That simple!</p> <p>The custom transition config object can take one of two forms for duration- vs. spring-based animations:</p>"},{"location":"troika-core/animations-and-transitions/#duration-based","title":"Duration-based","text":"<pre><code>transition: {\nz: {\nduration: 1234, //in ms, defaults to 750\neasing: 'easeInOutBounce', //easing function, defaults to 'easeOutCubic'\ndelay: 123, //in ms, defaults to 0\ninterpolate: 'number' //see \"Interpolation\" below\n}\n}\n</code></pre>"},{"location":"troika-core/animations-and-transitions/#spring-based","title":"Spring-based","text":"<pre><code>transition: {\nmyProp: {\nspring: true,\n// or spring: 'wobbly',\n// or spring: {mass, tension, friction},\ndelay: 250 //in ms, defaults to 0\n}\n}\n</code></pre> <p>The meanings of the spring configuration parameters, and the named presets, match those from react-spring.</p> <p>Note: Spring-based transitions do not currently support custom interpolations so they should only be used for numeric values.</p>"},{"location":"troika-core/animations-and-transitions/#animations","title":"Animations","text":"<p>Any descriptor can be given an <code>animation</code> property to define one or more keyframe animations for certain properties. Any animations will start running when the Facade is created and added to the scene. If any aspect of the <code>animation</code> is changed later, the old animation will be stopped and the new one will be started.</p> <p>Here's an example of an animation that will rotate the object indefinitely, looping every 1.5 seconds:</p> <pre><code>{\nfacade: MyObject,\nanimation: {\n0: {rotateY: 0},\n100: {rotateY: Math.PI * 2},\nduration: 1500,\niterations: Infinity\n}\n}\n</code></pre>"},{"location":"troika-core/animations-and-transitions/#animation-spec-structure","title":"Animation Spec Structure","text":""},{"location":"troika-core/animations-and-transitions/#keyframes","title":"keyframes","text":"<p>All animations need at least two keyframes. They are defined by numeric properties from <code>0</code> for the first frame to <code>100</code> for the last frame, or any number in between. Also the special property names <code>'from'</code> and <code>'to'</code> are aliases for <code>0</code> and <code>100</code> respectively.</p> <p>Each keyframe value is an object holding a set of properties and their target values at that keyframe. The values will be interpolated between the keyframes as the animation runs, applying them to the Facade instance.</p>"},{"location":"troika-core/animations-and-transitions/#duration","title":"duration","text":"<p>The number of milliseconds over which the animation's keyframes are run. If the animation loops (see <code>iterations</code>), this is the length of one iteration.</p>"},{"location":"troika-core/animations-and-transitions/#delay","title":"delay","text":"<p>A number of milliseconds to wait before starting the animation's first frame.</p>"},{"location":"troika-core/animations-and-transitions/#easing","title":"easing","text":"<p>An easing function for the animation, defaulting to \"linear\". This is applied to the whole animation's progression of keyframes, not individual keyframe segments.</p>"},{"location":"troika-core/animations-and-transitions/#iterations","title":"iterations","text":"<p>The number of times the animation should loop, defaulting to <code>1</code>. To loop endlessly, give it the value <code>Infinity</code>.</p>"},{"location":"troika-core/animations-and-transitions/#direction","title":"direction","text":"<p>Which direction the animation should progress: <code>\"forward\"</code> (the default), <code>\"backward\"</code>, or <code>\"alternate\"</code> to toggle between forward and backward every other iteration.</p>"},{"location":"troika-core/animations-and-transitions/#interpolate","title":"interpolate","text":"<p>Defines how non-numeric animated values should be interpolated between keyframes. It takes an object whose keys are property names and values are interpolators. For example:</p> <pre><code>interpolate: {\nemissive: 'color'\n}\n</code></pre>"},{"location":"troika-core/animations-and-transitions/#paused","title":"paused","text":"<p>If <code>true</code>, the animation will be paused at its current keyframe. This can be toggled on and off to pause and unpause the animation.</p>"},{"location":"troika-core/animations-and-transitions/#exit-animations","title":"Exit Animations","text":"<p>Since they start when a Facade instance \"enters\" the scene, it's often convenient to think of <code>animation</code> as defining \"entrance animations.\" Troika also supports \"exit animations\" which are applied when an object is removed from the scene. It will temporarily keep that object present in the scene long enough to run its exit animation, before fully destroying it. This allows you to do things like a nice smooth fade-out, scale-out, or fly-away rather than having objects abruptly disappear.</p> <p>To define an exit animation, simply give the descriptor an <code>exitAnimation</code> property. Its value matches the structure of a regular <code>animation</code>.</p>"},{"location":"troika-core/animations-and-transitions/#interpolation","title":"Interpolation","text":"<p>Transitions and animations will by default treat property values as numbers and interpolate their \"tweened\" values numerically. But some certain values, such as colors, require a different interpolation strategy.</p> <p>Troika supports the following named interpolations:</p> <ul> <li><code>\"number\"</code> - simple linear interpolation between two numeric values (the default).</li> <li><code>\"color\"</code> - interprets the start/end values as RGB colors, and interpolates each color channel independently. The start/end values can be 24-bit integers or any CSS color string value, and the interpolated values will always be returned as 24-bit integers (8 bits red, 8 bits green, 8 bits blue.)</li> </ul> <p>If you need a different interpolation, you can provide a custom function. Your function will take three parameters: the start value, the end value, and the progress between them (the output of the easing function) in the range from <code>0</code> to <code>1</code>. It must return an in-between value of the appropriate type.</p>"},{"location":"troika-core/facades/","title":"Facades","text":"<p>The <code>Facade</code> is the central concept in the Troika framework. It serves as the \"component\" unit for all objects, with the following responsibilities:</p> <ul> <li>Holding the object's current state, as a simple set of flat properties</li> <li>Synchronizing that state to a more complex model or imperative code</li> <li>Enforcing a simple, consistent object lifecycle</li> </ul> <p>In your app, you will define Facades to represent different types of objects in your scene. You will also make use of built-in Facade types that are specialized for specific purposes. </p> <p>Each Facade type is defined as a JavaScript <code>class</code>, extending the base <code>Facade</code> class. It has a few base methods, but otherwise each Facade class is free to define its own shape in the form of its public instance properties. Those properties will receive values from a scene descriptor or manual updates later on.</p> <p>See the base <code>Facade</code> class source for some additional class and method JSDoc.</p> <p>Why \"Facade\" instead of \"Component\"?</p> <p>The main reason for this naming choice was that \"Component\" is used by many other frameworks (React, Web Components, etc.) Since Troika will most likely be used as a subcomponent within another web framework, it felt confusing to have the same term referring to multiple things within the same app.</p> <p>Also, \"Facade\" is descriptive of its purpose: to create a simple public false-front that is backed by more complex code.</p>"},{"location":"troika-core/facades/#lifecycle","title":"Lifecycle","text":"<p>The facade lifecycle is intentionally very simple:</p>"},{"location":"troika-core/facades/#instantiation","title":"Instantiation","text":"<p>The Facade class's <code>constructor</code> is called, and is always passed a single argument which is the <code>parent</code> facade instance. Troika facades are never reparented, so that <code>parent</code> will remain the same for the lifetime of the instance. The <code>constructor</code> is a good place to perform any initialization for things that will remain for the facade's lifetime, such as creating backing objects, setting up event listeners, etc.</p>"},{"location":"troika-core/facades/#updates","title":"Updates","text":"<p>This is where the facade instance receives its state. Since \"state\" is defined as the facade object's properties, updating that state simply consists of assigning a set of property values. This is usually done by copying a scene descriptor's values directly onto the facade instance during a scene update pass. It can also be triggered manually via the facade's <code>update</code> method.</p> <p>This part of the lifecycle is also usually when the facade synchronizes its new state properties to its more complex backing object model.</p> <p>For properties that are \"standalone\", meaning they don't rely on any other properties, it is common for the facade class to define property accessors where the <code>set()</code> implementation updates the backing model right away.</p> <p>After all properties are updated, the special <code>afterUpdate()</code> lifecycle method will always be called. This method is where you can put any implementation code that uses multiple properties together, since you can rely on all those properties being up-to-date at this time.</p>"},{"location":"troika-core/facades/#destruction","title":"Destruction","text":"<p>When a facade instance is removed from the scene tree, its <code>destructor()</code> method is called. This is where you can perform teardown logic, dispose of backing objects, remove event listeners, etc.</p>"},{"location":"troika-core/facades/#events","title":"Events","text":"<p>Facades implement the EventTarget interface, so you can <code>addEventListener</code> just like you would a DOM element. Events dispatched this way can bubble, be cancelled, etc. as you'd expect.</p> <p>There is also a parallel messaging notification system that is used internally for sending large numbers of simple messages up the parent hierarchy in a highly optimized way. You likely won't need this, but see the <code>notifyWorld()</code> and <code>onNotifyWorld()</code> methods for more.</p> <p>See the section on Interactivity and Events for more.</p>"},{"location":"troika-core/facades/#example","title":"Example","text":"<p>Here's a very simple example of creating a Facade class that synchronizes some properties to a backing SuperComplicatedObject:</p> <pre><code>import { Facade } from 'troika-core'\n\nexport class MyThingFacade extends Facade {\n// Instantiation:\nconstructor (parent) {\nsuper(parent)\n\n// Init backing object:\nthis._impl = new SuperComplicatedObject()\n\n// Define state properties with initial values:\nthis.width = 1\nthis.height = 1\nthis.depth = 1\nthis.color = '#123456'\n}\n\n// Getter/setter for directly syncing a standalone property:\nset color (value) {\nthis._impl.setColor(value)\n}\n\nget color () {\nreturn this._impl.getColor()\n}\n\n// Handler for syncing interdependent properties:\nafterUpdate () {\nthis._impl.setDimensions(this.width, this.height, this.depth)\nsuper.afterUpdate() //don't forget the super call!\n}\n\n// Cleanup:\ndestructor () {\nthis._impl.teardown()\ndelete this._impl\nsuper.destructor()\n}\n}\n</code></pre> <p>This facade would then be created and updated using a scene descriptor like so:</p> <pre><code>{\nkey: 'thing1',\nfacade: MyThingFacade,\nwidth: 100,\nheight: 45,\ndepth: 23,\ncolor: '#336699'\n}\n</code></pre> <p>You'll learn more about scene descriptors in the next section.</p>"},{"location":"troika-core/facades/#special-facade-classes","title":"Special Facade Classes","text":"<p>The base <code>Facade</code> class is a superclass of all facades, but you will seldom extend it directly. You'll instead most often use a more specialized facade type. Here are some you may want to be aware of:</p>"},{"location":"troika-core/facades/#parentfacade","title":"ParentFacade","text":"<p>[Source] - This extends <code>Facade</code> with the ability to manage not only itself but also a set of child facades. At the end of its update phase it will recursively synchronize a set of child facade instances, based on an array of descriptor objects returned by its <code>describeChildren()</code> method (which by default returns the value of its <code>.children</code> property.)</p> <p>Most facade classes you will end up working with extend from <code>ParentFacade</code>.</p>"},{"location":"troika-core/facades/#listfacade","title":"ListFacade","text":"<p>[Source] - Inspired by D3, this is an optimized way to update many of the same type of object that skips creating intermediate descriptor objects for each item. For details see Data Lists.</p>"},{"location":"troika-core/facades/#object3dfacade-object2dfacade","title":"Object3DFacade, Object2DFacade","text":"<p>These are base facades for the <code>troika-3d</code> and <code>troika-2d</code> packages. If you are creating a 3D/2D graphical scene, you'll likely be extending these for most of your objects. See the docs for those packages for details.</p>"},{"location":"troika-core/facades/#notable-facade-methods","title":"Notable Facade Methods","text":""},{"location":"troika-core/facades/#updatevalues","title":"update({...values})","text":"<p>This convenience method allows you to set one or more of a facade's property values, automatically invoking the afterUpdate lifecycle method and requesting a render frame. Calling this from within an event handler, for example, allows facade components to update their own state.</p> <pre><code>myFacade.update({\nprop1: 'newValue1',\nprop2: 'newValue2'\n})\n</code></pre>"},{"location":"troika-core/facades/#requestrender","title":"requestRender()","text":"<p>This method notifies the top-level world manager that this object has changed in some way that affects its visible rendering, so a rendering frame will be scheduled.</p>"},{"location":"troika-core/facades/#getchildbykeykey","title":"getChildByKey(key)","text":"<p>This method looks for a direct child facade that was created with a given <code>key</code>. This is not often needed.</p>"},{"location":"troika-core/facades/#foreachchildfunc","title":"forEachChild(func)","text":"<p>This method lets you iterate a ParentFacade instance's direct child facades, invoking <code>func</code> for each child. This is not often needed, since updating children is usually better served by <code>update</code>.</p>"},{"location":"troika-core/facades/#traversefunc","title":"traverse(func)","text":"<p>This method lets you recursively traverse a facade instance and its entire subtree, depth-first, invoking <code>func</code> for each facade. This is not often needed, since updating a subtree is usually better served by <code>update</code>.</p>"},{"location":"troika-core/interactivity-and-events/","title":"Interactivity and Events","text":"<p>All Facades implement EventTarget, and mostly behave like DOM nodes in terms of how event listeners are added/removed and dispatched, including bubbling. In addition, Troika automatically dispatches certain handy events for you to utilize.</p>"},{"location":"troika-core/interactivity-and-events/#pointer-events","title":"Pointer Events","text":"<p>Both <code>troika-3d</code> and <code>troika-2d</code> automatically intercept mouse events on the canvas, find any visible objects intersecting the pointer (\"raycasting\"), and dispatch corresponding events on those facades. This lets you treat 2D/3D objects like you would HTML DOM nodes in terms of pointer interactions.</p> <p>Note: Also see Troika 3D's Interactivity and Events documentation for additional details and capabilities provided by pointer events in Troika 3D scenes.</p> <p>By default, objects in the scene will not intercept the pointer unless they have a listener for one of the pointer-related events. This is both because 3D scenes in particular often have semi-transparent things that you wouldn't want to interfere with selecting objects beyond, and also an optimization to avoid expensive raycasting of things that aren't needed.</p> <p>If necessary, you can set a facade's <code>pointerEvents</code> property to <code>true</code> to force raycasting of objects without pointer event listeners. Setting it to <code>false</code> will prevent raycasting even if a listener is present.</p> <p>Pointer events can be subscribed do either using <code>addEventListener</code> with the event name, or by assigning a corresponding <code>onEventName</code> property in a descriptor object. Since these events all bubble, you can also listen for them on container facades (as long as a visible descendant is set to intercept <code>pointerEvents</code>.)</p> <p>The following basic events are suppported:</p> Event Name Property Name mousemove onMouseMove mouseover onMouseOver mouseout onMouseOut mousedown onMouseDown mouseup onMouseUp click onClick dblclick onDoubleClick wheel onWheel <p>In addition, the following events are supported for drag-and-drop interactions. These work like the corresponding events in the HTML Drag and Drop API, just with Facades instead of DOM nodes.</p> Event Name Property Name dragstart onDragStart drag onDrag dragenter onDragEnter dragover onDragOver dragleave onDragLeave drop onDrop dragend onDragEnd"},{"location":"troika-core/interactivity-and-events/#pointer-states","title":"Pointer States","text":"<p>One of the most common uses of pointer events is to implement visual responses on hover or click. You can of course do this by adding \"mouseover\", \"mouseout\", etc. handlers which modify certain facade properties. But Troika also provides a handy declarative shortcut for this, <code>pointerStates</code>, which lets you define these effects much like <code>:hover</code> or <code>:active</code> in CSS.</p> <p>In your descriptor object, add a <code>pointerStates</code> property holding <code>hover</code> and/or <code>active</code> object values. Each of those defines a set of property values that will be applied upon mouseover/mousedown, and un-applied on mouseout/mouseup. For example:</p> <pre><code>{\nkey: 'foo',\nfacade: MyFacade,\ncolor: 'white',\npointerStates: {\nhover: {color: 'lightskyblue'},\nactive: {color: 'deepskyblue'}\n}\n}\n</code></pre>"},{"location":"troika-core/interactivity-and-events/#other-events","title":"Other Events","text":""},{"location":"troika-core/interactivity-and-events/#beforerender-afterrender","title":"beforerender, afterrender","text":"<p>These events are fired on any elements with listeners for them, immediately before and after the scene is rendered. This can be a good place to put logic that needs to run every frame. A beforerender handler is able to update the facade's state, prepare the backing implementation objects for rendering, etc.</p> <p>Note: this <code>beforerender</code> listener is different than Three.js's <code>Object3D.onBeforeRender()</code> -- it means \"before the scene renders\", not \"before this object renders\". The difference can be subtle; for example it will be fired for Group objects or other component facades without visible object renderings, and will fire even for objects that would be frustum-culled out of the rendered view.</p>"},{"location":"troika-core/interactivity-and-events/#custom-event-properties","title":"Custom Event Properties","text":"<p>When designing Facade components that fire events, you may want to expose named properties for those events so that handlers can be added via scene descriptors. You can use the static <code>Facade.defineEventProperty</code> function to add getters/setters for this purpose:</p> <pre><code>class TableFacade extends ParentFacade {\nonSomeAction() {\nthis.dispatchEvent(new CustomEvent('flip'))\n}\n}\n\n// Define an `onFlip` property that responds to the 'flip' event:\nFacade.defineEventProperty(\nTableFacade, //the facade class\n'onFlip', //the name of the property\n'flip' //the name of the event\n)\n\n// ...descriptor later on:\n{\nfacade: TableFacade,\nonFlip: e =&gt; { /* do something */ }\n}\n</code></pre>"},{"location":"troika-core/scene-descriptors/","title":"Scene Descriptors","text":"<p>The scene descriptor describes the structure of your scene at a point in time. As you apply new scene descriptors over time based on the changing state of your application, Troika tracks the differences from one descriptor to the next, and creates/destroys/updates a tree of Facade instances to match.</p> <p>Describing your scene declaratively this way removes the mental overhead of having to track and modify individual objects over time, making your scenes much easier to understand and debug.</p> <p>If you are familiar with React, this will feel very familiar. In fact Troika's scene descriptor model is highly inspired by React. The scene descriptor behaves very much like JSX descriptors, and Troika's Facades are in some ways similar to React's Components.</p>"},{"location":"troika-core/scene-descriptors/#a-basic-descriptor","title":"A Basic Descriptor","text":"<p>A descriptor is just a plain JS object with a set of properties. Here's a basic example:</p> <pre><code>{\nfacade: BallFacade,\nx: 1,\ny: 5,\nz: -10,\ncolor: 0x3333cc\n}\n</code></pre> <p>The only property that a descriptor must include is <code>facade</code>. It defines the specific <code>Facade</code> subclass that will be instantiated for this object.</p> <p>All the other properties are simply copied to that facade instance when the scene is updated. That specific facade's implementation controls what those properties mean in terms of their representation in your graphical scene. Typically this means syncing those property changes to a more complex underlying API such as a Three.js mesh/geometry/material.</p> <p>While Troika has a few built-in facade types, for the most part they will be something that you must implement for the kinds of objects in your scene. See Facade Basics for details and simple examples.</p>"},{"location":"troika-core/scene-descriptors/#special-descriptor-properties","title":"Special Descriptor Properties","text":"<p>While most properties are just copied to the facade instance, a few of them have special meanings:</p>"},{"location":"troika-core/scene-descriptors/#key","title":"<code>key</code>","text":"<p>A descriptor may include a <code>key</code> string property, identifying the specific facade instance corresponding to that descriptor object. The key must be unique among its siblings within a given parent.</p> <p>If omitted, Troika will generate a key internally based on the <code>facade</code> subclass and position among siblings. However it is recommended that you always include an explicit <code>key</code>, to avoid sometimes confusing situations with instance swapping, particularly when using animations and transitions.</p> <pre><code>{\nfacade: BallFacade,\nkey: 'ball1',\nx: -2\n},\n{\nfacade: BallFacade,\nkey: 'ball2',\nx: 2\n}\n</code></pre>"},{"location":"troika-core/scene-descriptors/#children","title":"<code>children</code>","text":"<p>Many Troika facades (those inheriting from <code>ParentFacade</code>) allow a <code>children</code> property, pointing to an array of child descriptors, or a single child descriptor object if there is only one.</p> <pre><code>{\nfacade: Group3DFacade,\nkey: 'group',\nrotateZ: Math.PI / 2,\nchildren: [\n{\nfacade: BallFacade,\nkey: 'ball1',\nx: -2\n},\n{\nfacade: BallFacade,\nkey: 'ball2',\nx: 2\n}\n]\n}\n</code></pre>"},{"location":"troika-core/scene-descriptors/#transition-animation-exitanimation","title":"<code>transition</code>, <code>animation</code>, <code>exitAnimation</code>","text":"<p>A descriptor with one of these properties causes the instantiated Facade class to be wrapped as <code>Animatable</code>, allowing you to declaratively define how other property values should change over time.</p> <p>These are based very closely on CSS Transitions and CSS Keyframe Animations, and are covered in detail in Animations and Transitions.</p>"},{"location":"troika-core/scene-descriptors/#pointerstates","title":"<code>pointerStates</code>","text":"<p>Similarly, the presence of a <code>pointerStates</code> property will wrap the facade instance so that it automatically changes its state in response to pointer events. This gives you declarative control over styling for <code>hover</code> and <code>active</code> states, much like CSS pseudoclasses, without having to write imperative event handlers every time. This is covered in detail in Interactivity and Events.</p>"},{"location":"troika-core/scene-descriptors/#ref","title":"<code>ref</code>","text":"<p>If your code needs a reference to the <code>Facade</code> object instantiated for a given descriptor, you can give it a <code>ref</code> property pointing to a function. That function will be called, passed the facade instance as its argument, when the facade is created. It will also be called, with <code>null</code> as its argument, when the facade is destroyed (removed from the scene.)</p> <p>If the <code>ref</code> is reassigned to a different function during an update, the old one will be called with <code>null</code> and the new one will be called with the facade instance. This is usually not what you want, so to avoid this churn make sure the exact same function is passed across updates.</p> <pre><code>function ballRefFunction(ballFacade) {\nconsole.log('BallFacade was ' + (ballFacade ? 'created' : 'destroyed'))\n}\n\n//...\n\n{\nfacade: BallFacade,\nkey: 'ball',\nref: ballRefFunction\n}\n</code></pre> <p>As in React, there is seldom a need to use <code>ref</code>, but it can be a useful tool in those rare cases.</p>"},{"location":"troika-core/scene-descriptors/#data-lists","title":"Data Lists","text":"<p>In cases where you need to describe a large number of scene objects, such as when you are mapping from a large set of data items, it is inefficient to create a large array of <code>children</code> with a scene descriptor object for each item. Troika provides a <code>ListFacade</code> to handle these cases more efficiently.</p> <p>Instead of a descriptor object for each item, you define a single descriptor object bound to a <code>data</code> array, with a <code>template</code> object that describes how the items in that <code>data</code> array should be mapped to facade instances.</p> <pre><code>import {ListFacade} from 'troika-3d'\n\n//...\n\n{\nfacade: ListFacade,\nkey: 'myList',\ndata: myArrayOfDataItems,\ntemplate: {\nfacade: BallFacade,\nkey: d =&gt; d.id,\nx: (d, i) =&gt; i * 2,\ny: d =&gt; d.value / maxValue * 10,\nz: -10\n}\n}\n</code></pre> <p>This pattern is inspired by how d3.js binds data to attributes without creating a full set of intermediary objects.</p> <p>Each property in the <code>template</code> can either be a constant literal value (e.g. a number or string), or a function. Literals will be copied directly to each spawned child. Functions will be called for each item, passing three arguments: the current item from the <code>data</code> array, the current index in the array, and the full array. The value returned by the function will be copied to that child facade.</p> <p>In cases where you want an actual function to be copied, such as assigning event handlers, you will need to wrap those in a function that returns your function.</p> <pre><code>  template: {\n//...\nonClick: () =&gt; this.onBallClicked\n}\n</code></pre>"},{"location":"troika-core/scene-descriptors/#alternate-jsx-syntax","title":"Alternate JSX syntax","text":"<p>If you are using React for the rest of your application, it can sometimes be confusing to have to step between using JSX for React content descriptors and the plain JS object descriptors for Troika content. To smooth this over, Troika is able to accept JSX elements in place of most JS object descriptors, assuming your build pipeline pre-transforms JSX to <code>React.createElement()</code> calls.</p> <p>When representing Troika descriptors in JSX, the <code>facade</code> value is used as the JSX element name, <code>children</code> are represented as nested JSX child elements, and all other properties are written as JSX attributes.</p> <p>For example:</p> <pre><code>{\nfacade: Group3DFacade,\nkey: 'grp',\nrotateZ: Math.PI / 2,\nchildren: [\n{\nfacade: BallFacade,\nkey: 'ball1',\nx: -2\n},\n{\nfacade: BallFacade,\nkey: 'ball2',\nx: 2\n}\n]\n}\n</code></pre> <p>...is equivalent to:</p> <pre><code>&lt;Group3DFacade\nkey=\"group\"\nrotateZ={Math.PI / 2}\n&gt;\n&lt;BallFacade\nkey=\"ball1\"\nx={-2}\n/&gt;\n&lt;BallFacade\nkey=\"ball2\"\nx={2}\n/&gt;\n&lt;/Group3DFacade&gt;\n</code></pre> <p>While the JSX sugar can often be more readable, it does have a slight performance impact due to more transient objects being created and <code>React.createElement()</code>'s own internal logic being run for each element. Try to avoid it and stick with plain JS descriptors when your scene contains a large number of them.</p>"},{"location":"troika-three-text/","title":"Troika Text for Three.js","text":"<p>The <code>troika-three-text</code> package provides high quality text rendering in Three.js scenes, using signed distance fields (SDF) and antialiasing using standard derivatives.</p> <p>Rather than relying on pre-generated SDF textures, this parses font files (.ttf, .otf, .woff) directly using Typr, and generates the SDF atlas for glyphs on-the-fly as they are used. It also handles proper kerning, ligature glyph substitution, right-to-left/bidirectional layout, joined scripts like Arabic, and will automatically load fallback fonts for full unicode coverage. All font parsing, SDF generation, and glyph layout is performed in a web worker to prevent frame drops.</p> <p>Once the SDFs are generated, it assembles a geometry that positions all the glyphs, and patches any Three.js Material with the proper shader code for rendering the SDFs. This means you can still benefit from all the features of Three.js's built-in materials like lighting, physically-based rendering, shadows, and fog.</p>"},{"location":"troika-three-text/#demos","title":"Demos","text":"<ul> <li>With the Troika scene management framework</li> <li>With react-three-fiber</li> <li>With a video texture</li> <li>With the Material Icons font</li> <li>With in-place editing</li> </ul>"},{"location":"troika-three-text/#with-other-frameworks","title":"With Other Frameworks","text":"<ul> <li>In the <code>drei</code> utilities for react-three-fiber</li> <li>As an A-Frame component</li> <li>As a Web Component in three-elements</li> </ul>"},{"location":"troika-three-text/#screenshots","title":"Screenshots","text":""},{"location":"troika-three-text/#installation","title":"Installation","text":"<p>Get it from NPM:</p> <pre><code>npm install troika-three-text\n</code></pre> <p>You will also need to install a compatible version of Three.js; see the notes on Three.js versions in the Getting Started docs for details.</p> <pre><code>npm install three\n</code></pre>"},{"location":"troika-three-text/#usage","title":"Usage","text":"<pre><code>import {Text} from 'troika-three-text'\n</code></pre> <p>You can then use the <code>Text</code> class like any other Three.js mesh:</p> <pre><code>// Create:\nconst myText = new Text()\nmyScene.add(myText)\n\n// Set properties to configure:\nmyText.text = 'Hello world!'\nmyText.fontSize = 0.2\nmyText.position.z = -2\nmyText.color = 0x9966FF\n\n// Update the rendering:\nmyText.sync()\n</code></pre> <p>It's a good idea to call the <code>.sync()</code> method after changing any properties that would affect the text's layout. If you don't, it will be called automatically on the next render frame, but calling it yourself can get the result sooner.</p> <p>When you're done with the <code>Text</code> instance, be sure to call <code>dispose</code> on it to prevent a memory leak:</p> <pre><code>myScene.remove(myText)\nmyText.dispose()\n</code></pre>"},{"location":"troika-three-text/#supported-properties","title":"Supported properties","text":"<p>Instances of <code>Text</code> support the following configuration properties:</p>"},{"location":"troika-three-text/#text","title":"<code>text</code>","text":"<p>The string of text to be rendered. Newlines and repeating whitespace characters are honored.</p> <p>Default: none</p>"},{"location":"troika-three-text/#anchorx","title":"<code>anchorX</code>","text":"<p>Defines the horizontal position in the text block that should line up with the local origin. Can be specified as a numeric <code>x</code> position in local units, a string percentage of the total text block width e.g. <code>'25%'</code>, or one of the following keyword strings: <code>'left'</code>, <code>'center'</code>, or <code>'right'</code>.</p> <p>Default: <code>0</code></p>"},{"location":"troika-three-text/#anchory","title":"<code>anchorY</code>","text":"<p>Defines the vertical position in the text block that should line up with the local origin. Can be specified as a numeric <code>y</code> position in local units (note: down is negative y), a string percentage of the total text block height e.g. <code>'25%'</code>, or one of the following keyword strings: <code>'top'</code>, <code>'top-baseline'</code>, <code>'top-cap'</code>, <code>'top-ex'</code>, <code>'middle'</code>, <code>'bottom-baseline'</code>, or <code>'bottom'</code>.</p> <p>Default: <code>0</code></p>"},{"location":"troika-three-text/#cliprect","title":"<code>clipRect</code>","text":"<p>If specified, defines the <code>[minX, minY, maxX, maxY]</code> of a rectangle outside of which all pixels will be discarded. This can be used for example to clip overflowing text when <code>whiteSpace='nowrap'</code>.</p> <p>Default: none</p>"},{"location":"troika-three-text/#color","title":"<code>color</code>","text":"<p>This is a shortcut for setting the <code>color</code> of the text's <code>material</code>. You can use this if you don't want to specify a whole custom <code>material</code> and just want to change its color.</p> <p>Use the <code>material</code> property if you want to control aspects of the material other than its color.</p> <p>Default: none - uses the color of the <code>material</code></p>"},{"location":"troika-three-text/#curveradius","title":"<code>curveRadius</code>","text":"<p>Defines a cylindrical radius along which the text's plane will be curved. Positive numbers put the cylinder's centerline (oriented vertically) that distance in front of the text, for a concave curvature, while negative numbers put it behind the text for a convex curvature. The centerline will be aligned with the text's local origin; you can use <code>anchorX</code> to offset it.</p> <p>Since each glyph is by default rendered with a simple quad, each glyph remains a flat plane internally. You can use <code>glyphGeometryDetail</code> to add more vertices for curvature inside glyphs.</p> <p>Default: <code>0</code></p>"},{"location":"troika-three-text/#depthoffset","title":"<code>depthOffset</code>","text":"<p>This is a shortcut for setting the material's <code>polygonOffset</code> and related properties, which can be useful in preventing z-fighting when this text is laid on top of another plane in the scene. Positive numbers are further from the camera, negatives closer.</p> <p>Be aware that while this can help with z-fighting, it does not affect the rendering order; if the text renders before the content behind it, you may see antialiasing pixels that appear too dark or light. You may need to also change the text mesh's <code>renderOrder</code>, or set its <code>z</code> position a fraction closer to the camera, to ensure the text renders after background objects.</p> <p>Default: <code>0</code></p>"},{"location":"troika-three-text/#direction","title":"<code>direction</code>","text":"<p>Sets the base direction for the text. The default value of \"auto\" will choose a direction based on the text's content according to the bidi spec. A value of \"ltr\" or \"rtl\" will force the direction.</p> <p>Default: <code>'auto'</code></p>"},{"location":"troika-three-text/#fillopacity","title":"<code>fillOpacity</code>","text":"<p>Controls the opacity of just the glyph's fill area, separate from any configured <code>strokeOpacity</code>, <code>outlineOpacity</code>, and the material's <code>opacity</code>. A <code>fillOpacity</code> of <code>0</code> will make the fill invisible, leaving just the stroke and/or outline.</p> <p>Default: <code>1</code></p>"},{"location":"troika-three-text/#font","title":"<code>font</code>","text":"<p>The URL of a custom font file to be used. Supported font formats are: * .ttf * .otf * .woff (.woff2 is not supported)</p> <p>Default: The Roboto font loaded from Google Fonts CDN</p>"},{"location":"troika-three-text/#fontsize","title":"<code>fontSize</code>","text":"<p>The em-height at which to render the font, in local world units.</p> <p>Default: <code>0.1</code></p>"},{"location":"troika-three-text/#fontstyle","title":"<code>fontStyle</code>","text":"<p>Either <code>\"italic\"</code> or <code>\"normal\"</code>. Currently only used to select the preferred style for the fallback Unicode fonts.</p> <p>Default: <code>\"normal\"</code></p>"},{"location":"troika-three-text/#fontweight","title":"<code>fontWeight</code>","text":"<p>A numeric font weight, <code>\"normal\"</code>, or <code>\"bold\"</code>. Currently only used to select the preferred weight for the fallback Unicode fonts.</p> <p>Default: <code>\"normal\"</code></p>"},{"location":"troika-three-text/#glyphgeometrydetail","title":"<code>glyphGeometryDetail</code>","text":"<p>The number of vertical/horizontal segments that make up each glyph's rectangular plane. This can be increased to provide more geometrical detail for custom vertex shader effects, for example.</p> <p>Default: <code>1</code></p>"},{"location":"troika-three-text/#gpuacceleratesdf","title":"<code>gpuAccelerateSDF</code>","text":"<p>When <code>true</code>, the SDF generation process will be GPU-accelerated with WebGL when possible, making it much faster especially for complex glyphs, and falling back to a JavaScript version executed in web workers when support isn't available. It should automatically detect support, but it's still somewhat experimental, so you can set it to <code>false</code> to force it to use the JS version if you encounter issues with it.</p> <p>Default: <code>true</code></p>"},{"location":"troika-three-text/#letterspacing","title":"<code>letterSpacing</code>","text":"<p>Sets a uniform adjustment to spacing between letters after kerning is applied, in local world units. Positive numbers increase spacing and negative numbers decrease it.</p> <p>Default: <code>0</code></p>"},{"location":"troika-three-text/#lineheight","title":"<code>lineHeight</code>","text":"<p>Sets the height of each line of text. Can either be <code>'normal'</code> which chooses a reasonable height based on the chosen font's ascender/descender metrics, or a number that is interpreted as a multiple of the <code>fontSize</code>.</p> <p>Default: <code>'normal'</code></p>"},{"location":"troika-three-text/#material","title":"<code>material</code>","text":"<p>Defines a Three.js Material instance to be used as a base when rendering the text. This material will be automatically replaced with a new material derived from it, that adds shader code to decrease the alpha for each fragment (pixel) outside the text glyphs, with antialiasing.</p> <p>By default it will derive from a simple white `MeshBasicMaterial, but you can use any of the other mesh materials to gain other features like lighting, texture maps, etc.</p> <p>Also see the <code>color</code> shortcut property.</p> <p>Note that because your material instance is replaced by a derived material instance, any changes you make to your original material will not be reflected in the derived version. If you need to modify properties of the material afterward, be sure you get a new reference to the derived version:</p> <pre><code>// Bad:\ntext.material = myOrigMaterial\nmyOrigMaterial.opacity = 0.5\n\n// Good:\ntext.material = myOrigMaterial\ntext.material.opacity = 0.5\n</code></pre> <p>Default: a <code>MeshBasicMaterial</code> instance</p>"},{"location":"troika-three-text/#maxwidth","title":"<code>maxWidth</code>","text":"<p>The maximum width of the text block, above which text may start wrapping according to the <code>whiteSpace</code> and <code>overflowWrap</code> properties.</p> <p>Default: <code>Infinity</code>, meaning text will never wrap</p>"},{"location":"troika-three-text/#outlineblur","title":"<code>outlineBlur</code>","text":"<p>Specifies a blur radius applied to the outer edge of the text's <code>outlineWidth</code>. If the <code>outlineWidth</code> is zero, the blur will be applied at the glyph edge, like CSS's <code>text-shadow</code> blur radius. A blur plus a nonzero <code>outlineWidth</code> can give a solid outline with a fuzzy outer edge.</p> <p>The blur radius can be specified as either an absolute number in local units, or as a percentage string e.g. <code>\"12%\"</code> which is treated as a percentage of the <code>fontSize</code>.</p> <p>Default: <code>0</code></p>"},{"location":"troika-three-text/#outlinecolor","title":"<code>outlineColor</code>","text":"<p>The color to use for the text outline when <code>outlineWidth</code>, <code>outlineBlur</code>, and/or <code>outlineOffsetX/Y</code> are set. Accepts a ThreeJS <code>Color</code> object, or a number/string accepted by <code>Color#set</code>.</p> <p>Default: black</p>"},{"location":"troika-three-text/#outlineoffsetx-outlineoffsety","title":"<code>outlineOffsetX</code>, <code>outlineOffsetY</code>","text":"<p>These define a horizontal and vertical offset of the text outline. Using an offset with <code>outlineWidth: 0</code> creates a drop-shadow effect like CSS's <code>text-shadow</code>; also see <code>outlineBlur</code>. </p> <p>The offsets can be specified as either an absolute number in local units, or as a percentage string e.g. <code>\"12%\"</code> which is treated as a percentage of the <code>fontSize</code>.</p> <p>Default: <code>0</code></p>"},{"location":"troika-three-text/#outlineopacity","title":"<code>outlineOpacity</code>","text":"<p>Sets the opacity of a configured text outline, in the range <code>0</code> to <code>1</code>.</p> <p>Default: <code>1</code></p>"},{"location":"troika-three-text/#outlinewidth","title":"<code>outlineWidth</code>","text":"<p>The width of an outline/halo to be drawn around each text glyph using the <code>outlineColor</code> and <code>outlineOpacity</code>. This can help improve readability when the text is displayed against a background of low or varying contrast. </p> <p>The width can be specified as either an absolute number in local units, or as a percentage string e.g. <code>\"10%\"</code> which is interpreted as a percentage of the <code>fontSize</code>.</p> <p>Default: <code>0</code></p>"},{"location":"troika-three-text/#overflowwrap","title":"<code>overflowWrap</code>","text":"<p>Defines how text wraps if the <code>whiteSpace</code> property is <code>'normal'</code>. Can be either <code>'normal'</code> to break at whitespace characters, or <code>'break-word'</code> to allow breaking within words.</p> <p>Default: <code>'normal'</code></p>"},{"location":"troika-three-text/#sdfglyphsize","title":"<code>sdfGlyphSize</code>","text":"<p>Allows overriding the default size of each glyph's SDF (signed distance field) used when rendering this text instance. This must be a power-of-two number. Larger sizes can improve the quality of glyph rendering by increasing the sharpness of corners and preventing loss of very thin lines, at the expense of increased memory footprint and longer SDF generation time.</p> <p>Default: <code>64</code></p>"},{"location":"troika-three-text/#strokecolor","title":"<code>strokeColor</code>","text":"<p>The color of the text stroke, when <code>strokeWidth</code> is nonzero. Accepts a ThreeJS <code>Color</code> object, or a number/string accepted by <code>Color#set</code>.</p> <p>Default: grey</p>"},{"location":"troika-three-text/#strokeopacity","title":"<code>strokeOpacity</code>","text":"<p>The opacity of the text stroke, when <code>strokeWidth</code> is nonzero. Accepts a number from <code>0</code> to <code>1</code>.</p> <p>Default: <code>1</code></p>"},{"location":"troika-three-text/#strokewidth","title":"<code>strokeWidth</code>","text":"<p>Sets the width of a stroke drawn inside the edge of each text glyph, using the <code>strokeColor</code> and <code>strokeOpacity</code>.</p> <p>The width can be specified as either an absolute number in local units, or as a percentage string e.g. <code>\"10%\"</code> which is interpreted as a percentage of the <code>fontSize</code>.</p> <p>Default: <code>0</code></p>"},{"location":"troika-three-text/#textalign","title":"<code>textAlign</code>","text":"<p>The horizontal alignment of each line of text within the overall text bounding box. Can be one of <code>'left'</code>, <code>'right'</code>, <code>'center'</code>, or <code>'justify'</code>.</p> <p>Default: <code>'left'</code></p>"},{"location":"troika-three-text/#textindent","title":"<code>textIndent</code>","text":"<p>An indentation applied to the first character of each hard newline. Behaves like CSS <code>text-indent</code>.</p> <p>Default: <code>0</code></p>"},{"location":"troika-three-text/#unicodefontsurl","title":"<code>unicodeFontsUrl</code>","text":"<p>A custom hosting location for unicode-font-resolver data index and font files, if you want to self-host them rather than using the default CDN. See Unicode Fallback Fonts below for details.</p>"},{"location":"troika-three-text/#whitespace","title":"<code>whiteSpace</code>","text":"<p>Defines whether text should wrap when a line reaches the <code>maxWidth</code>. Can be either <code>'normal'</code>, to allow wrapping according to the <code>overflowWrap</code> property, or <code>'nowrap'</code> to prevent wrapping.</p> <p>Note that <code>'normal'</code> in this context does honor newline characters to manually break lines, making it behave more like <code>'pre-wrap'</code> does in CSS.</p> <p>Default: <code>'normal'</code></p>"},{"location":"troika-three-text/#unicode-fallback-fonts","title":"Unicode Fallback Fonts","text":"<p>When a character is not covered by the configured <code>font</code> file, unicode-font-resolver will be used to query for an appropriate fallback font. All Unicode character ranges supported by the Google Noto Fonts are covered this way.</p> <p>By default, the unicode-font-resolver data index and font files are loaded from the jsDelivr CDN. If you wish to self-host those files you can do so; however be aware the full set of data and fonts is nearly 300MB.</p> <p>To self-host the files:</p> <ul> <li>Go to the unicode-font-resolver Github tags page</li> <li>Find the tag matching the version of <code>@unicode-font-resolver/client</code> declared in <code>troika-three-text/package.json</code>'s <code>devDependencies</code>.</li> <li>Download the source code .zip or .tar.gz for that release and unpack it.</li> <li>Copy the contents of the <code>packages/data/</code> directory to your server where you want to host it.</li> <li>Configure troika-three-text to load from that server URL:<ul> <li>Per Text instance:   <pre><code>text.unicodeFontsURL = 'https://my.host/unicode-fonts-data'\n</code></pre></li> <li>Globally:   <pre><code>import {configureTextBuilder} from 'troika-three-text'\n\nconfigureTextBuilder({\nunicodeFontsURL: 'https://my.host/unicode-fonts-data'\n})\n</code></pre></li> </ul> </li> </ul>"},{"location":"troika-three-text/#handling-asynchronous-updates","title":"Handling Asynchronous Updates","text":"<p>Since the text processing occurs in a web worker, it is by definition asynchronous. This means that you can't rely on the text being visible or having a complete geometry immediately. If you need to do things like access the geometry's <code>boundingSphere</code> or the <code>textRenderInfo</code>, you will have to listen for completion. You can do this two ways:</p> <ol> <li> <p>Pass a callback function when you call the <code>sync</code> method:</p> <pre><code>myText.sync(() =&gt; {\n// code to execute after sync completes...\n})\n</code></pre> <p>This is best when you want to only react to that specific sync call. Keep in mind that the callback will not execute if the text is already fully synced.</p> </li> <li> <p>Add a listener for the <code>synccomplete</code> event:</p> <pre><code>myText.addEventListener('synccomplete', () =&gt; {\n// code to execute after sync completes...\n})\n</code></pre> <p>This will fire after every sync, no matter who invoked it. This is best if you need to react to all syncs, for example to trigger a manual canvas render.</p> <p>You can also listen for the <code>syncstart</code> event if you need to react to the initiation of a sync call, e.g. to set some sort of \"waiting\" state while the text is being processed.</p> </li> </ol>"},{"location":"troika-three-text/#disabling-web-worker","title":"Disabling web worker","text":"<p>Some environments don't allow evaluating JS strings for security reasons, like those with a restrictive CSP, which blocks how troika-three-text creates its web worker. Or you may want to avoid using a worker for some other reason. You can force it to run on the main thread instead (although still asynchronously) by configuring it prior to creating any Text instances:</p> <pre><code>import {configureTextBuilder} from 'troika-three-text'\n\nconfigureTextBuilder({\nuseWorker: false\n})\n</code></pre>"},{"location":"troika-three-text/#preloading","title":"Preloading","text":"<p>To avoid long pauses when first displaying a piece of text in your scene, you can preload fonts and optionally pre-generate the SDF textures for particular glyphs up front:</p> <pre><code>import {preloadFont} from 'troika-three-text'\n\nmyApp.showLoadingScreen()\n\npreloadFont(\n{\nfont: 'path/to/myfontfile.woff', characters: 'abcdefghijklmnopqrstuvwxyz'\n},\n() =&gt; {\nmyApp.showScene()\n}\n)\n</code></pre> <p>The arguments are:</p> <ul> <li> <p><code>options</code></p> </li> <li> <p><code>options.font</code> - The URL of the font file to preload. If <code>null</code> is passed, this will preload the default font.</p> </li> <li> <p><code>options.characters</code> - A string or array of string character sequences for which to pre-generate glyph SDF textures. Note that this will honor ligature substitution, so you may need to specify ligature sequences in addition to their individual characters to get all possible glyphs, e.g. <code>[\"t\", \"h\", \"th\"]</code> to get the \"t\" and \"h\" glyphs plus the \"th\" glyph.</p> </li> <li> <p><code>options.sdfGlyphSize</code> - The size at which to prerender the SDFs for the <code>characters</code> glyphs. See the <code>sdfGlyphSize</code> config property on <code>Text</code> for details about SDF sizes. If not specified, will use the default SDF size.</p> </li> <li> <p><code>callback</code> - A function that will be called when the preloading is complete.</p> </li> </ul>"},{"location":"troika-three-text/#postprocessing","title":"Postprocessing","text":"<p>It is possible to use <code>Text</code> within scenes that utilize the postprocessing library for applying image effects. However, you must enable a special mode in that library that allows <code>Text</code>'s custom material to be honored. Just do the following once somewhere in your code:</p> <pre><code>import { OverrideMaterialManager } from 'postprocessing'\n\nOverrideMaterialManager.workaroundEnabled = true\n</code></pre>"},{"location":"troika-three-text/#carets-and-selection-ranges","title":"Carets and Selection Ranges","text":"<p>In addition to rendering text, it is possible to access positioning information for caret placement and selection ranges. To access that info, use the <code>getCaretAtPoint</code> and <code>getSelectionRects</code> utility functions. Both of these functions take a <code>textRenderInfo</code> object as input, which you can get from the <code>Text</code> object's <code>textRenderInfo</code> property after sync has completed. See \"Handling Asynchronous Updates\" above for how to react to sync completion events.</p>"},{"location":"troika-three-text/#getcaretatpointtextrenderinfo-x-y","title":"<code>getCaretAtPoint(textRenderInfo, x, y)</code>","text":"<p>This returns the caret position nearest to a given x/y position in the local text plane. This is useful for placing an editing caret based on a click or ther raycasted event. The return value is an object with the following properties:</p> <ul> <li><code>x</code> - x position of the caret</li> <li><code>y</code> - y position of the caret's bottom</li> <li><code>height</code> - height of the caret, based on the current fontSize and lineHeight</li> <li><code>charIndex</code> - the index in the original input string of this caret's target character. The caret will be for the position before that character. For the final caret position, this will be equal to the string length. For ligature glyphs, this will be for the first character in the ligature sequence.</li> </ul>"},{"location":"troika-three-text/#getselectionrectstextrenderinfo-start-end","title":"<code>getSelectionRects(textRenderInfo, start, end)</code>","text":"<p>This returns a list of rectangles covering all the characters within a given character range. This is useful for highlighting a selection range. The return value is an array of objects, each with <code>{left, top, right, bottom}</code> properties in the local text plane.</p>"},{"location":"troika-three-utils/BezierMesh/","title":"BezierMesh","text":"<p>This is a Three.js object which bends a cylindrical mesh along a 3D cubic bezier path between two points. This is useful for drawing nicely curved lines in 3D space, where the lines have thickness.</p> <p>Rather than assembling a BufferGeometry on the CPU, BezierMesh bends the tube on the GPU in a custom derived vertex shader. This makes it very good for situations where the line's endpoints and control points change over time. They can even be animated every frame without penalty.</p> <p>It can also have any <code>material</code> assigned to it, so it can have lighting, textures, etc. like any other mesh. It will automatically upgrade that material behind the scenes to apply the extra vertex shader transformation. </p> <ul> <li> <p>Source code with JSDoc</p> </li> <li> <p>Online example</p> </li> </ul> <p></p> <ul> <li>Online example using InstancedUniformsMesh</li> </ul> <p></p>"},{"location":"troika-three-utils/BezierMesh/#usage","title":"Usage:","text":"<pre><code>import { BezierMesh } from 'troika-three-utils'\n\nconst bezier = new BezierMesh()\nbezier.pointA.set(-0.3, 0.4, -0.3)\nbezier.controlA.set(0.7, 0.6, 0.4)\nbezier.controlB.set(-0.6, -0.6, -0.6)\nbezier.pointB.set(0.7, 0, -0.7)\nbezier.radius = 0.01\nscene.add(bezier)\n</code></pre>"},{"location":"troika-three-utils/BezierMesh/#supported-properties","title":"Supported Properties:","text":""},{"location":"troika-three-utils/BezierMesh/#pointa","title":"<code>pointA</code>","text":"<p>A Vector3 holding the position of the first endpoint.</p>"},{"location":"troika-three-utils/BezierMesh/#controla","title":"<code>controlA</code>","text":"<p>A Vector3 holding the position of the first control point.</p>"},{"location":"troika-three-utils/BezierMesh/#controlb","title":"<code>controlB</code>","text":"<p>A Vector3 holding the position of the second control point.</p>"},{"location":"troika-three-utils/BezierMesh/#pointb","title":"<code>pointB</code>","text":"<p>A Vector3 holding the position of the second endpoint.</p>"},{"location":"troika-three-utils/BezierMesh/#radius","title":"<code>radius</code>","text":"<p>A number defining the radius of the tube.</p>"},{"location":"troika-three-utils/BezierMesh/#dasharray","title":"<code>dashArray</code>","text":"<p>An array of two numbers, defining the length of \"on\" and \"off\" parts of a dashed line style. Each number is a 0-1 ratio of the entire path's length. (Actually this is the <code>t</code> length used as input to the cubic bezier function, not its visible length.)</p> <p>Note that the dashes will appear like a hollow tube, not solid; this will be more apparent on thicker tubes.</p>"},{"location":"troika-three-utils/BezierMesh/#dashoffset","title":"<code>dashOffset</code>","text":"<p>A numeric offset of where the dash starts. You can animate this to make the dashes move.</p>"},{"location":"troika-three-utils/createDerivedMaterial/","title":"Three.js Derived Materials","text":"<p>How to use Troika's <code>createDerivedMaterial</code> utility to extend existing Three.js materials with custom shader code</p> <p>Source code with JSDoc</p> <p>One of the most powerful things about Three.js is its excellent set of built-in materials. They provide many features like physically-based reflectivity, shadows, texture maps, fog, and so on, building the very complex shaders behind the scenes.</p> <p>But sometimes you need to do something custom in the shaders, such as move around the vertices, or change the colors or transparency of certain pixels. You could use a ShaderMaterial but then you lose all the built-in features. The experimental NodeMaterial seems promising but doesn't appear to be ready as a full replacement.</p> <p>The onBeforeCompile hook lets you intercept the shader code and modify it, but in practice there are quirks to this that make it difficult to work with, not to mention the complexity of forming regular expressions to inject your custom shader code in the right places.</p> <p>Troika's <code>createDerivedMaterial(baseMaterial, options)</code> utility handles all that complexity, letting you \"extend\" a built-in Material's shaders via a declarative interface. The resulting material can be prototype-chained to the base material so it picks up changes to its properties. It has methods for generating depth and distance materials so your shader modifications can be reflected in shadow maps. </p> <p>Lastly, you can create a derived material from another derived material, and so on. This enables composable patterns where you can piece in small bits of shader logic one at a time.</p> <p>Here's a simple example that injects an auto-incrementing <code>elapsed</code> uniform holding the current time, and uses that to transform the vertices in a wave pattern.</p> <pre><code>import { createDerivedMaterial} from 'troika-three-utils'\nimport { Mesh, MeshStandardMaterial, PlaneGeometry } from 'three'\n\nconst baseMaterial = new MeshStandardMaterial({color: 0xffcc00})\nconst customMaterial = createDerivedMaterial(\nbaseMaterial,\n{\ntimeUniform: 'elapsed',\n// Add GLSL to tweak the vertex... notice this modifies the `position`\n// and `normal` attributes, which is normally not possible!\nvertexTransform: `\n      float waveAmplitude = 0.1;\n      float waveX = uv.x * PI * 4.0 - mod(elapsed / 300.0, PI2);\n      float waveZ = sin(waveX) * waveAmplitude;\n      normal.xyz = normalize(vec3(-cos(waveX) * waveAmplitude, 0.0, 1.0));\n      position.z += waveZ;\n    `\n}\n)\nconst mesh = new Mesh(\nnew PlaneGeometry(1, 1, 64, 1),\ncustomMaterial\n)\n\n// to enable directional light shadows:\nmesh.castShadow = true\nmesh.customDepthMaterial = customMaterial.getDepthMaterial()\n</code></pre> <p>You can also declare custom <code>uniforms</code> and <code>defines</code>, inject fragment shader code to modify the output color, etc. See the JSDoc in the DerivedMaterial.js source code for full details.</p>"},{"location":"troika-worker-utils/","title":"<code>troika-worker-utils</code>","text":"<p>This package provides utilities for making Web Workers easier to use.</p>"},{"location":"troika-worker-utils/#worker-modules","title":"Worker Modules","text":"<p>Troika's \"Worker Modules\" system, exposed by the <code>defineWorkerModule</code> export, allows you to define a function that will be executed with a web worker. This provides a simple interface for moving chunks of logic off the main thread, which can be critical in WebGL/WebXR scenes where frame rate cannot be interrupted by long-running code.</p> <p>Similar utilities like Greenlet have existed for a while. However, <code>defineWorkerModule</code> introduces the ability for worker modules to depend on one another. This means you can define modular chunks of code in separate functions, and then inject them into a worker where they can reference and call each other.</p>"},{"location":"troika-worker-utils/#defineworkermoduleoptions","title":"<code>defineWorkerModule(options)</code>","text":"<p>This function defines a Worker Module. It takes an <code>options</code> object that can contain the following:</p>"},{"location":"troika-worker-utils/#optionsinit","title":"options.init","text":"<p>Required. This is the main function that initializes the module; it will be executed within the Worker the first time it is invoked. If any <code>dependencies</code> are defined, the resolved values of those dependencies will be passed in as arguments.</p> <p>Its return value becomes the module's \"value\". That can be:</p> <ul> <li> <p>A function, which can be called any number of times from the main thread by calling the function returned from <code>defineWorkerModule()</code>.</p> </li> <li> <p>Any other value, which will be used as the value passed to the <code>init</code> of other worker modules using it as a dependency.</p> </li> </ul> <p>Note: As with any function-in-worker utility, the <code>init</code> function must not use any variables from the parent closure in which it is defined; its internal content must be completely standalone. Any external values you want to use must be passed in as <code>dependencies</code>.</p>"},{"location":"troika-worker-utils/#optionsdependencies","title":"options.dependencies","text":"<p>An optional array of dependencies required by the init function. Dependencies can be:</p> <ul> <li> <p>Primitives like strings, numbers, booleans</p> </li> <li> <p>Functions; these will be stringified and rehydrated within the worker so they must not depend on anything from their parent closures</p> </li> <li> <p>Other worker modules created by <code>defineWorkerModule</code>; these will be resolved within the worker, and therefore modules that provide functions can be called without having to cross the worker/main thread boundary.</p> </li> </ul>"},{"location":"troika-worker-utils/#optionsgettransferables","title":"options.getTransferables","text":"<p>An optional function that will be run in the worker just before posting the response value from a module call back to the main thread. This function will be passed that response value, and if it returns an array then that will be used as the \"transferables\" parameter to <code>postMessage</code>. Use this if there are values in the response that can/should be transfered rather than cloned.</p>"},{"location":"troika-worker-utils/#optionsname","title":"options.name","text":"<p>An optional descriptive name for this module; this can be useful for debugging (it will be inserted as a comment into the Blob sent to the worker) but is not currently used for anything else.</p>"},{"location":"troika-worker-utils/#optionsworkerid","title":"options.workerId","text":"<p>By default all modules will run in the same dedicated worker, but if you want to use multiple workers you can pass a <code>workerId</code> string to indicate a specific worker to spawn. Note that each worker is completely standalone and no data or state will be shared between them. If a worker module is used as a dependency by worker modules using different <code>workerId</code>s, then that dependency will be re-registered in each worker.</p>"},{"location":"troika-worker-utils/#return-value","title":"Return Value","text":"<p>The value returned by <code>defineWorkerModule</code> is a function. If your <code>options.init</code> returned a function, then this will be how you can invoke that within the worker. Call it, and it will give you a Promise for its return value.</p>"},{"location":"troika-worker-utils/#contrived-example","title":"Contrived Example","text":"<pre><code>import { defineWorkerModule } from 'troika-worker-utils'\n\n// A simple module with a value:\nconst workerModuleA = defineWorkerModule({\ninit: function() {\nreturn Math.PI\n}\n})\n\n// A module that depends on the previous module:\nconst workerModuleB = defineWorkerModule({\ndependencies: [\nworkerModuleA\n],\ninit: function(moduleAValue) {\n// moduleAValue here is \"I'm the value of Module A!\" from the first init function\n\n// This return function can be invoked by calling workerModuleB in the main thread:\nlet callCount = 0\nreturn function(arg) {\nreturn `Called module B ${++callCount} times, ` + `with arg \"${arg}\". Module A's value was ${moduleAValue}.`\n}\n}\n})\n\nworkerModuleB('foo') // \"Called module B 1 times, with arg \"foo\". Module A's value was 3.141592653589793.\"\nworkerModuleB('bar') // \"Called module B 2 times, with arg \"bar\". Module A's value was 3.141592653589793.\"\n</code></pre>"},{"location":"troika-xr/","title":"WebXR","text":"<p>The <code>troika-xr</code> package adds WebXR capabilities to <code>troika-3d</code> scenes. These capabilities include:</p> <ul> <li>UI for launching a WebXR session</li> <li>Stereoscopic camera rendering</li> <li>6DoF head tracking</li> <li>Controller tracking with pointer raycasting integrated into the main event system</li> <li>A few basic helper facades for things like teleportation and menus</li> </ul> <p>Note: while definitely usable, this package is still somewhat lacking in configurability and features. Requests and contributions are welcome.</p>"},{"location":"troika-xr/#usage","title":"Usage","text":"<p>The <code>troika-xr</code> package must be installed in addition to <code>troika-3d</code>.</p> <p>Currently, the only provided entry point for WebXR support is via a React higher-order component named <code>ReactXRAware</code>. This assumes that your Troika scene uses the <code>Canvas3D</code> React component as its entry point, which itself is managed by some parent React component.</p> <p>To inject WebXR support, you need to use the <code>ReactXRAware</code> HOC to wrap that parent React component. The HOC function can also be passed several config properties to customize the XR session it will create. (TODO add details here or link to the source code JSDoc...)</p> <p>Note: The HOC must wrap the <code>Canvas3D</code>'s parent rather than the <code>Canvas3D</code> directly because it is going to provide you with a UI button for launching the XR session, which you must place into the DOM outside the canvas.</p> <p>The wrapped React component will now be provided with a few new props for you to use:</p> <ul> <li><code>xrSupported</code> - a boolean indicating any level of browser support for WebXR.</li> <li><code>xrSupportedSessionModes</code> - an array of supported XR session modes (currently \"inline\" and/or \"immersive-vr\").</li> <li><code>xrSession</code> - a reference to the <code>XRSession</code> object when an XR session is active, or <code>null</code> when there is no active session. You can use this to customize content based on whether the user is in XR or not.</li> <li><code>xrSessionMode</code> - the current session mode when an XR session is active (currently \"inline\" or \"immersive-vr\").</li> <li><code>xrReferenceSpace</code> - a reference to the current <code>XRReferenceSpace</code> when an XR session is active, or <code>null</code> otherwise.</li> <li><code>xrReferenceSpaceType</code> - the current reference space type (\"bounded-floor\" etc.).</li> <li><code>xrLauncher</code> - a React element that you should place into your render function, which provides the user a UI button for launching their WebXR session.</li> </ul>"},{"location":"troika-xr/#example-hoc-setup","title":"Example HOC Setup","text":"<pre><code>import { ReactXRAware } from './XRAware.js'\n\nclass App extends React.Component {\nrender() {\nreturn &lt;div className=\"my_app\"&gt;\n&lt;Canvas3D\ncamera={{\n// Camera x/y/z/etc. set here controls its base world position, and\n// headset 6DoF tracking will be applied relative to that.\n}}\nobjects={[\nthis.props.xrSession ? {\n// some object that is only present in XR\n} : null,\n\n//...other scene objects\n]}\n/&gt;\n\n{\n// This is the button that lets the user launch into XR!\nthis.props.xrLauncher\n}\n&lt;/div&gt;\n}\n}\n\nexport const XRApp = ReactXRAware(App, {\n//...XR options\n})\n</code></pre>"},{"location":"troika-xr/#interaction-events","title":"Interaction Events","text":"<p>When in an XR session, hand controllers will be automatically added to the scene and be synchronized to their <code>XRInputSource</code> positions.</p> <p>NOTE: rendering of controllers is currently very basic, with only Oculus controllers and a very basic fallback model. Integration of more controller types is planned.</p> <p>XRInputSources that provide a target ray will automatically be used to raycast objects in the scene, and hits will be mapped to normal pointer events (mouseover/mousemove/drag/etc.) just like on screen. Likewise, controller buttons will map to mousedown/up/click events, and thumbsticks will map to wheel events. This lets you define your events the same way for screens and XR, for the most part.</p> <p>While these events won't have screen-specific properties like <code>clientX</code>, they will always carry a <code>ray</code> property holding the <code>THREE.Ray</code> that triggered the hit. (That's also true for all events in non-XR <code>troika-3d</code>, so it's usually safer to use the <code>ray</code> than things like <code>clientX</code>.)</p> <p>Additionally, each event will have a <code>eventSource</code> property holding a reference to the <code>XRInputSource</code> facade that triggered it. This allows you to distinguish which pointer fired an event when you have two hands pointing at different things. </p>"}]}